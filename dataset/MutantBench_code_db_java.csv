id,code
0,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
1,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt * 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
2,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength / offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
3,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt - 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
4,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() == 0 || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
5,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() == 1 || delimLen == 1) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
6,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || false || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
7,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 0;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
8,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str.length() == 0 || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
9,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() == 0 || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 1; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
10,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt % 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
11,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength % offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
12,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() <= 0 || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
13,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength - offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
14,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt == 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
15,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength * offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
16,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength % 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
17,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) <= ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
18,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() == 0 || delimLen >= 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
19,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) >= ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
20,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength / offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
21,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? 0 : delimiters.length;
    if (str == null || str.length() == 0 || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
22,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if ((str == null || str.length() == 0) != (delimLen == 0)) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
23,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (true) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
24,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength * offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
25,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt / 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
26,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
27,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    ;
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
28,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset != wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
29,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 0;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
30,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 0) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
31,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() == 0 || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (false) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
32,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength - offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
33,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset >= wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
34,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() == 0 || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = true;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
35,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + -1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
36,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
37,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (false) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
38,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt > 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
39,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() == -1 || delimLen == -1) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
40,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt / 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
41,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength / offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
42,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 0;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
43,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() == 0 || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            ;
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
44,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength % offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
45,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = -1;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
46,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 1;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
47,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() == 0 || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i != strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
48,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() == 0 || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; false; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
49,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    ;
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
50,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (false) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
51,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() == 0 || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = false;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
52,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt == offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
53,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + -1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
54,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    ;
    return wrappedLine.toString();
}"
55,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null != (str.length() == 0) || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
56,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength / 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
57,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                ;
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
58,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength % offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
59,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                ;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
60,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() == 0 || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (false) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
61,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() == 0 || delimLen <= 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
62,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = false ? -1 : delimiters.length;
    if (str == null || str.length() == 0 || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
63,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            ;
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
64,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (true) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
65,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength * 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
66,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength % offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
67,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() == 0 || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (true) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
68,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() == 0 || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (true) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
69,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (true || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
70,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (false) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
71,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= -1) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
72,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + -32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
73,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 0 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
74,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength - 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
75,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength - offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
76,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() == 0 || false) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
77,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (true) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
78,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() == 0 || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i <= strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
79,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength <= 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
80,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    ;
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
81,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() == 0 || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = false;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
82,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 1) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
83,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt % 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
84,"public static java.lang.String wrap( java.lang.String str, int wrapLength )
{
    return wrap( str, wrapLength, null, false );
}"
85,"public static java.lang.String wrap( java.lang.String str, int wrapLength )
{
    return wrap( str, wrapLength, null, true );
}"
86,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            ;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
87,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt > offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
88,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength + offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
89,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (false) {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
90,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength / offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
91,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength * offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
92,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() == 0 || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = -1; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
93,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() == 0 || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                ;
            }
        }
    }
    return buffer.toString();
}"
94,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < -1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
95,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            ;
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
96,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                ;
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
97,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = -1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
98,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? 1 : delimiters.length;
    if (str == null || str.length() == 0 || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
99,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (true) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
100,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (false) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
101,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (false) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
102,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength * offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
103,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt * 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
104,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
105,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (str == null || str.length() >= 0 || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
106,"public static java.lang.String capitalize( java.lang.String str, char[] delimiters )
{
    int delimLen = delimiters == null ? -1 : delimiters.length;
    if (false || str.length() == 0 || delimLen == 0) {
        return str;
    }
    int strLen = str.length();
    java.lang.StringBuffer buffer = new java.lang.StringBuffer(strLen);
    boolean capitalizeNext = true;
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (isDelimiter(ch, delimiters)) {
            buffer.append(ch);
            capitalizeNext = true;
        } else {
            if (capitalizeNext) {
                buffer.append(Character.toTitleCase( ch ));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
    }
    return buffer.toString();
}"
107,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength != 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt + 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
108,"public static java.lang.String wrap( java.lang.String str, int wrapLength, java.lang.String newLineStr, boolean wrapLongWords )
{
    if (str == null) {
        return null;
    }
    if (newLineStr == null) {
        newLineStr = SystemUtils.LINE_SEPARATOR;
    }
    if (wrapLength < 1) {
        wrapLength = 1;
    }
    int inputLineLength = str.length();
    int offset = 0;
    java.lang.StringBuffer wrappedLine = new java.lang.StringBuffer( inputLineLength + 32 );
    while (inputLineLength - offset > wrapLength) {
        if (str.charAt(offset) == ' ') {
            offset++;
            continue;
        }
        int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);
        if (spaceToWrapAt >= offset) {
            wrappedLine.append(str.substring(offset, spaceToWrapAt));
            wrappedLine.append(newLineStr);
            offset = spaceToWrapAt - 1;
        } else {
            if (wrapLongWords) {
                wrappedLine.append(str.substring(offset, wrapLength + offset));
                wrappedLine.append(newLineStr);
                offset += wrapLength;
            } else {
                spaceToWrapAt = str.indexOf(' ', wrapLength + offset);
                if (spaceToWrapAt >= 0) {
                    wrappedLine.append(str.substring(offset, spaceToWrapAt));
                    wrappedLine.append(newLineStr);
                    offset = spaceToWrapAt + 1;
                } else {
                    wrappedLine.append(str.substring(offset));
                    offset = inputLineLength;
                }
            }
        }
    }
    wrappedLine.append(str.substring(offset));
    return wrappedLine.toString();
}"
109,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
110,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() * 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
111,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
112,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length - 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
113,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (false) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
114,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (false
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
115,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length * 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
116,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (false) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
117,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                ;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
118,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() * 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
119,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
120,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
121,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (true) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
122,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 0;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
123,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() / 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
124,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length % 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
125,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c <= escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
126,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 0;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
127,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; false; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
128,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(1, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
129,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i != length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
130,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(1);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
131,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; false; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
132,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (false) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
133,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                ;
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
134,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || false) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
135,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            ;
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
136,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() + 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
137,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 1) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
138,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
139,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = -1;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
140,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i <= length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
141,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 0);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
142,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c >= dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
143,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length / 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
144,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                ;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
145,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - -1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
146,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i != 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
147,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i >= length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
148,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c <= dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
149,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                ;
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
150,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > -1) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
151,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() % 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
152,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i <= length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
153,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i != length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
154,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c <= dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
155,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() + 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
156,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(1);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
157,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() / 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
158,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i >= 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
159,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c >= escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
160,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() % 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
161,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(false ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
162,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c <= escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
163,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (false) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
164,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i <= length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
165,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar == name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
166,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar != (c == escapeReplacementFirstChar)) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
167,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (false && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
168,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                ;
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
169,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 1;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
170,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c >= dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
171,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + -8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
172,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        ;
    }
    return s;
}"
173,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(-1);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
174,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c >= escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
175,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(-1, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
176,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - -1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
177,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(-1);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (c == dollarReplacementFirstChar || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
178,"private String decodeName(String name) {
    final WeakReference ref = (WeakReference)unescapeCache.get(name);
    String s = (String)(ref == null ? null : ref.get());

    if (s == null) {
        final char dollarReplacementFirstChar = dollarReplacement.charAt(0);
        final char escapeReplacementFirstChar = escapeCharReplacement.charAt(0);
        final int length = name.length();

        // First, fast (common) case: nothing to decode
        int i = 0;

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            // We'll do a quick check for potential match
            if (false || c == escapeReplacementFirstChar) {
                // and if it might be a match, just quit, will check later on
                break;
            }
        }

        if (i == length) {
            return name;
        }

        // Otherwise full processing
        final StringBuffer result = new StringBuffer(length + 8);

        // We know first N chars are safe
        if (i > 0) {
            result.append(name.substring(0, i));
        }

        for (; i < length; i++ ) {
            char c = name.charAt(i);
            if (c == dollarReplacementFirstChar && name.startsWith(dollarReplacement, i)) {
                i += dollarReplacement.length() - 1;
                result.append('$');
            } else if (c == escapeReplacementFirstChar
                && name.startsWith(escapeCharReplacement, i)) {
                i += escapeCharReplacement.length() - 1;
                result.append('_');
            } else {
                result.append(c);
            }
        }

        s = result.toString();
        unescapeCache.put(name, new WeakReference(s));
    }
    return s;
}"
179,"public static void main(int number) {
    int[] a = new int[] { -14, 6, 28, 0 };
    int mytemp1, mytemp2, end, i, j;
    System.out.println(""original array is:\n"");
    for (i = 0; i < 3; i++) {
        System.out.printf(""%5d"", a[i]);
    }
    System.out.printf(""\n"");
    System.out.printf(""insert a new number:"");
    end = a[2];
    if (number >= end) {
        a[3] = number;
    } else {
        for (i = 0; i < 3; i++) {
            if (a[i] > number) {
                mytemp1 = a[i];
                a[i] = number;
                for (j = i + 1; j < 4; j++) {
                    mytemp2 = a[j];
                    a[j] = mytemp1;
                    mytemp1 = mytemp2;
                }
                break;
            }
        }
    }
    for (i = 0; i < 4; i++) {
        System.out.printf(""%6d"", a[i]);
    }
    System.out.printf(""\n"");
}"
180,"public static void main(int number) {
    int[] a = new int[] { -14, 6, 28, 0 };
    int mytemp1, mytemp2, end, i, j;
    System.out.println(""original array is:\n"");
    for (i = 0; i < 3; i++) {
        System.out.printf(""%5d"", a[i]);
    }
    System.out.printf(""\n"");
    System.out.printf(""insert a new number:"");
    end = a[2];
    if (number >= end++) {
        a[3] = number;
    } else {
        for (i = 0; i < 3; i++) {
            if (a[i] > number) {
                mytemp1 = a[i];
                a[i] = number;
                for (j = i + 1; j < 4; j++) {
                    mytemp2 = a[j];
                    a[j] = mytemp1;
                    mytemp1 = mytemp2;
                }
                break;
            }
        }
    }
    for (i = 0; i < 4; i++) {
        System.out.printf(""%6d"", a[i]);
    }
    System.out.printf(""\n"");
}"
181,"public static void main(int number) {
    int[] a = new int[] { -14, 6, 28, 0 };
    int mytemp1, mytemp2, end, i, j;
    System.out.println(""original array is:\n"");
    for (i = 0; i < 3; i++) {
        System.out.printf(""%5d"", a[i]);
    }
    System.out.printf(""\n"");
    System.out.printf(""insert a new number:"");
    end = a[2];
    if (number >= end) {
        a[3] = number;
    } else {
        for (i = 0; i < 3; i++) {
            if (a[i] > number) {
                mytemp1 = a[i];
                a[i] = number++;
                for (j = i + 1; j < 4; j++) {
                    mytemp2 = a[j];
                    a[j] = mytemp1;
                    mytemp1 = mytemp2;
                }
                break;
            }
        }
    }
    for (i = 0; i < 4; i++) {
        System.out.printf(""%6d"", a[i]);
    }
    System.out.printf(""\n"");
}"
182,"public static void main(int number) {
    int[] a = new int[] { -14, 6, 28, 0 };
    int mytemp1, mytemp2, end, i, j;
    System.out.println(""original array is:\n"");
    for (i = 0; i < 3; i++) {
        System.out.printf(""%5d"", a[i]);
    }
    System.out.printf(""\n"");
    System.out.printf(""insert a new number:"");
    end = Math.abs(a[2]);
    if (number >= end) {
        a[3] = number;
    } else {
        for (i = 0; i < 3; i++) {
            if (a[i] > number) {
                mytemp1 = a[i];
                a[i] = number;
                for (j = i + 1; j < 4; j++) {
                    mytemp2 = a[j];
                    a[j] = mytemp1;
                    mytemp1 = mytemp2;
                }
                break;
            }
        }
    }
    for (i = 0; i < 4; i++) {
        System.out.printf(""%6d"", a[i]);
    }
    System.out.printf(""\n"");
}"
183,"public static void main(int number) {
    int[] a = new int[] { -14, 6, 28, 0 };
    int mytemp1, mytemp2, end, i, j;
    System.out.println(""original array is:\n"");
    for (i = 0; i < 3; i++) {
        System.out.printf(""%5d"", a[i]);
    }
    System.out.printf(""\n"");
    System.out.printf(""insert a new number:"");
    end = a[2];
    if (number >= end--) {
        a[3] = number;
    } else {
        for (i = 0; i < 3; i++) {
            if (a[i] > number) {
                mytemp1 = a[i];
                a[i] = number;
                for (j = i + 1; j < 4; j++) {
                    mytemp2 = a[j];
                    a[j] = mytemp1;
                    mytemp1 = mytemp2;
                }
                break;
            }
        }
    }
    for (i = 0; i < 4; i++) {
        System.out.printf(""%6d"", a[i]);
    }
    System.out.printf(""\n"");
}"
184,"public static void main(int number) {
    int[] a = new int[] { -14, 6, 28, 0 };
    int mytemp1, mytemp2, end, i, j;
    System.out.println(""original array is:\n"");
    for (i = 0; i < 3; i++) {
        System.out.printf(""%5d"", a[i]);
    }
    System.out.printf(""\n"");
    System.out.printf(""insert a new number:"");
    end = a[2];
    if (number >= end) {
        a[3] = number;
    } else {
        for (i = 0; i < 3; i++) {
            if (a[i] > number) {
                mytemp1 = a[i];
                a[i] = number;
                for (j = i + 1; j < 4; j++) {
                    mytemp2 = a[j]++;
                    a[j] = mytemp1;
                    mytemp1 = mytemp2;
                }
                break;
            }
        }
    }
    for (i = 0; i < 4; i++) {
        System.out.printf(""%6d"", a[i]);
    }
    System.out.printf(""\n"");
}"
185,"public static void main(int number) {
    int[] a = new int[] { -14, 6, 28, 0 };
    int mytemp1, mytemp2, end, i, j;
    System.out.println(""original array is:\n"");
    for (i = 0; i < 3; i++) {
        System.out.printf(""%5d"", a[i]);
    }
    System.out.printf(""\n"");
    System.out.printf(""insert a new number:"");
    end = a[2];
    if (number >= end) {
        a[3] = number;
    } else {
        for (i = 0; i < 3; i++) {
            if (a[i] > number) {
                mytemp1 = a[i]--;
                a[i] = number;
                for (j = i + 1; j < 4; j++) {
                    mytemp2 = a[j];
                    a[j] = mytemp1;
                    mytemp1 = mytemp2;
                }
                break;
            }
        }
    }
    for (i = 0; i < 4; i++) {
        System.out.printf(""%6d"", a[i]);
    }
    System.out.printf(""\n"");
}"
186,"public static void main(int number) {
    int[] a = new int[] { -14, 6, 28, 0 };
    int mytemp1, mytemp2, end, i, j;
    System.out.println(""original array is:\n"");
    for (i = 0; i < 3; i++) {
        System.out.printf(""%5d"", a[i]);
    }
    System.out.printf(""\n"");
    System.out.printf(""insert a new number:"");
    end = a[2];
    if (number >= end) {
        a[3] = number;
    } else {
        for (i = 0; i < 3; i++) {
            if (a[i] > number) {
                mytemp1 = a[i];
                a[i] = number;
                for (j = i + 1; j < 4; j++) {
                    mytemp2 = a[j];
                    a[j] = mytemp1;
                    mytemp1 = mytemp2--;
                }
                break;
            }
        }
    }
    for (i = 0; i < 4; i++) {
        System.out.printf(""%6d"", a[i]);
    }
    System.out.printf(""\n"");
}"
187,"public static void main(int number) {
    int[] a = new int[] { -14, 6, 28, 0 };
    int mytemp1, mytemp2, end, i, j;
    System.out.println(""original array is:\n"");
    for (i = 0; i < 3; i++) {
        System.out.printf(""%5d"", a[i]);
    }
    System.out.printf(""\n"");
    System.out.printf(""insert a new number:"");
    end = a[2];
    if (number >= end) {
        a[3] = number;
    } else {
        for (i = 0; i < 3; i++) {
            if (a[i] > number) {
                mytemp1 = a[i];
                a[i] = number;
                for (j = i + 1; j < 4; j++) {
                    mytemp2 = a[j];
                    a[j] = mytemp1;
                    mytemp1 = mytemp2;
                }
                break;
            }
        }
    }
    for (i = 0; i < 4; i++) {
        System.out.printf(""%6d"", a[i]++);
    }
    System.out.printf(""\n"");
}"
188,"public static void main(int number) {
    int[] a = new int[] { -14, 6, 28, 0 };
    int mytemp1, mytemp2, end, i, j;
    System.out.println(""original array is:\n"");
    for (i = 0; i < 3; i++) {
        System.out.printf(""%5d"", a[i]);
    }
    System.out.printf(""\n"");
    System.out.printf(""insert a new number:"");
    end = a[2];
    if (number >= end) {
        a[3] = number;
    } else {
        for (i = 0; i < 3; i++) {
            if (a[i] > number) {
                mytemp1 = a[i];
                a[i] = number--;
                for (j = i + 1; j < 4; j++) {
                    mytemp2 = a[j];
                    a[j] = mytemp1;
                    mytemp1 = mytemp2;
                }
                break;
            }
        }
    }
    for (i = 0; i < 4; i++) {
        System.out.printf(""%6d"", a[i]);
    }
    System.out.printf(""\n"");
}"
189,"public static void main(int number) {
    int[] a = new int[] { -14, 6, 28, 0 };
    int mytemp1, mytemp2, end, i, j;
    System.out.println(""original array is:\n"");
    for (i = 0; i < 3; i++) {
        System.out.printf(""%5d"", a[i]);
    }
    System.out.printf(""\n"");
    System.out.printf(""insert a new number:"");
    end = a[2];
    if (number >= end) {
        a[3] = number++;
    } else {
        for (i = 0; i < 3; i++) {
            if (a[i] > number) {
                mytemp1 = a[i];
                a[i] = number;
                for (j = i + 1; j < 4; j++) {
                    mytemp2 = a[j];
                    a[j] = mytemp1;
                    mytemp1 = mytemp2;
                }
                break;
            }
        }
    }
    for (i = 0; i < 4; i++) {
        System.out.printf(""%6d"", a[i]);
    }
    System.out.printf(""\n"");
}"
190,"public static void main(int number) {
    int[] a = new int[] { -14, 6, 28, 0 };
    int mytemp1, mytemp2, end, i, j;
    System.out.println(""original array is:\n"");
    for (i = 0; i < 3; i++) {
        System.out.printf(""%5d"", a[i]);
    }
    System.out.printf(""\n"");
    System.out.printf(""insert a new number:"");
    end = a[2];
    if (number >= end) {
        a[3] = number;
    } else {
        for (i = 0; i < 3; i++) {
            if (a[i] > number) {
                mytemp1 = a[i];
                a[i] = number;
                for (j = i + 1; j < 4; j++) {
                    mytemp2 = a[j]--;
                    a[j] = mytemp1;
                    mytemp1 = mytemp2;
                }
                break;
            }
        }
    }
    for (i = 0; i < 4; i++) {
        System.out.printf(""%6d"", a[i]);
    }
    System.out.printf(""\n"");
}"
191,"public static void main(int number) {
    int[] a = new int[] { -14, 6, 28, 0 };
    int mytemp1, mytemp2, end, i, j;
    System.out.println(""original array is:\n"");
    for (i = 0; i < 3; i++) {
        System.out.printf(""%5d"", a[i]);
    }
    System.out.printf(""\n"");
    System.out.printf(""insert a new number:"");
    end = a[2];
    if (number >= end) {
        a[3] = number;
    } else {
        for (i = 0; i < 3; i++) {
            if (a[i] >= number) {
                mytemp1 = a[i];
                a[i] = number;
                for (j = i + 1; j < 4; j++) {
                    mytemp2 = a[j];
                    a[j] = mytemp1;
                    mytemp1 = mytemp2;
                }
                break;
            }
        }
    }
    for (i = 0; i < 4; i++) {
        System.out.printf(""%6d"", a[i]);
    }
    System.out.printf(""\n"");
}"
192,"public static void main(int number) {
    int[] a = new int[] { -14, 6, 28, 0 };
    int mytemp1, mytemp2, end, i, j;
    System.out.println(""original array is:\n"");
    for (i = 0; i < 3; i++) {
        System.out.printf(""%5d"", a[i]);
    }
    System.out.printf(""\n"");
    System.out.printf(""insert a new number:"");
    end = a[2];
    if (number >= end) {
        a[3] = number;
    } else {
        for (i = 0; i < 3; i++) {
            if (a[i] > number) {
                mytemp1 = a[i];
                a[i] = number;
                for (j = i + 1; j < 4; j++) {
                    mytemp2 = a[j];
                    a[j] = mytemp1++;
                    mytemp1 = mytemp2;
                }
                break;
            }
        }
    }
    for (i = 0; i < 4; i++) {
        System.out.printf(""%6d"", a[i]);
    }
    System.out.printf(""\n"");
}"
193,"public static void main(int number) {
    int[] a = new int[] { -14, 6, 28, 0 };
    int mytemp1, mytemp2, end, i, j;
    System.out.println(""original array is:\n"");
    for (i = 0; i < 3; i++) {
        System.out.printf(""%5d"", a[i]);
    }
    System.out.printf(""\n"");
    System.out.printf(""insert a new number:"");
    end = a[2];
    if (number >= end) {
        a[3] = number;
    } else {
        for (i = 0; i < 3; i++) {
            if (a[i] > number) {
                mytemp1 = a[i];
                a[i] = number;
                for (j = i + 1; j < 4; j++) {
                    mytemp2 = a[j];
                    a[j] = mytemp1;
                    mytemp1 = mytemp2;
                }
                break;
            }
        }
    }
    for (i = 0; i < 4; i++) {
        System.out.printf(""%6d"", a[i]--);
    }
    System.out.printf(""\n"");
}"
194,"public static void main(int number) {
    int[] a = new int[] { -14, 6, 28, 0 };
    int mytemp1, mytemp2, end, i, j;
    System.out.println(""original array is:\n"");
    for (i = 0; i < 3; i++) {
        System.out.printf(""%5d"", a[i]);
    }
    System.out.printf(""\n"");
    System.out.printf(""insert a new number:"");
    end = a[2];
    if (number >= end) {
        a[3] = number;
    } else {
        for (i = 0; i < 3; i++) {
            if (a[i] > number) {
                mytemp1 = a[i]++;
                a[i] = number;
                for (j = i + 1; j < 4; j++) {
                    mytemp2 = a[j];
                    a[j] = mytemp1;
                    mytemp1 = mytemp2;
                }
                break;
            }
        }
    }
    for (i = 0; i < 4; i++) {
        System.out.printf(""%6d"", a[i]);
    }
    System.out.printf(""\n"");
}"
195,"public static void main(int number) {
    int[] a = new int[] { -14, 6, 28, 0 };
    int mytemp1, mytemp2, end, i, j;
    System.out.println(""original array is:\n"");
    for (i = 0; i < 3; i++) {
        System.out.printf(""%5d"", a[i]);
    }
    System.out.printf(""\n"");
    System.out.printf(""insert a new number:"");
    end = a[2];
    if (number >= end) {
        a[3] = Math.abs(number);
    } else {
        for (i = 0; i < 3; i++) {
            if (a[i] > number) {
                mytemp1 = a[i];
                a[i] = number;
                for (j = i + 1; j < 4; j++) {
                    mytemp2 = a[j];
                    a[j] = mytemp1;
                    mytemp1 = mytemp2;
                }
                break;
            }
        }
    }
    for (i = 0; i < 4; i++) {
        System.out.printf(""%6d"", a[i]);
    }
    System.out.printf(""\n"");
}"
196,"public static void main(int number) {
    int[] a = new int[] { -14, 6, 28, 0 };
    int mytemp1, mytemp2, end, i, j;
    System.out.println(""original array is:\n"");
    for (i = 0; i < 3; i++) {
        System.out.printf(""%5d"", a[i]);
    }
    System.out.printf(""\n"");
    System.out.printf(""insert a new number:"");
    end = a[2];
    if (number >= end) {
        a[3] = number;
    } else {
        for (i = 0; i < 3; i++) {
            if (a[i] > number) {
                mytemp1 = a[i];
                a[i] = number;
                for (j = i + 1; j < 4; j++) {
                    mytemp2 = a[j];
                    a[j] = mytemp1;
                    mytemp1 = mytemp2++;
                }
                break;
            }
        }
    }
    for (i = 0; i < 4; i++) {
        System.out.printf(""%6d"", a[i]);
    }
    System.out.printf(""\n"");
}"
197,"public static void main(int number) {
    int[] a = new int[] { -14, 6, 28, 0 };
    int mytemp1, mytemp2, end, i, j;
    System.out.println(""original array is:\n"");
    for (i = 0; i < 3; i++) {
        System.out.printf(""%5d"", a[i]);
    }
    System.out.printf(""\n"");
    System.out.printf(""insert a new number:"");
    end = a[2];
    if (number >= end) {
        a[3] = number--;
    } else {
        for (i = 0; i < 3; i++) {
            if (a[i] > number) {
                mytemp1 = a[i];
                a[i] = number;
                for (j = i + 1; j < 4; j++) {
                    mytemp2 = a[j];
                    a[j] = mytemp1;
                    mytemp1 = mytemp2;
                }
                break;
            }
        }
    }
    for (i = 0; i < 4; i++) {
        System.out.printf(""%6d"", a[i]);
    }
    System.out.printf(""\n"");
}"
198,"public static void main(int number) {
    int[] a = new int[] { -14, 6, 28, 0 };
    int mytemp1, mytemp2, end, i, j;
    System.out.println(""original array is:\n"");
    for (i = 0; i < 3; i++) {
        System.out.printf(""%5d"", a[i]);
    }
    System.out.printf(""\n"");
    System.out.printf(""insert a new number:"");
    end = a[2];
    if (number >= end) {
        a[3] = number;
    } else {
        for (i = 0; i < 3; i++) {
            if (a[i] > number) {
                mytemp1 = a[i];
                a[i] = number;
                for (j = i + 1; j < 4; j++) {
                    mytemp2 = a[j];
                    a[j] = mytemp1--;
                    mytemp1 = mytemp2;
                }
                break;
            }
        }
    }
    for (i = 0; i < 4; i++) {
        System.out.printf(""%6d"", a[i]);
    }
    System.out.printf(""\n"");
}"
199,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
200,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j % 1] = temp;
            }
        }
    }
}"
201,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[~j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
202,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[1];
                data[j - 1] = temp;
            }
        }
    }
}"
203,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
    }
}"
204,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length + 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
205,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j];
                data[j - 1] = temp;
            }
        }
    }
}"
206,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] <= data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
207,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp++;
            }
        }
    }
}"
208,"public  void sort( int[] data )
{
    for (int i = 0; i < 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
209,"public  void sort( int[] data )
{
    for (int i = 0; i <= data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
210,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i;) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
211,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] != data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
212,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[--j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
213,"public  void sort( int[] data )
{
    for (int i = 0;; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
214,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1;; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
215,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] > data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
216,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] == data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
217,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; j++) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
218,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[--j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
219,"public  void sort( int[] data )
{
    for (int i = 0; --i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
220,"public  void sort( int[] data )
{
    for (int i = 0; true; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
221,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[1] = temp;
            }
        }
    }
}"
222,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j++];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
223,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = ~temp;
            }
        }
    }
}"
224,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j + 1] = temp;
            }
        }
    }
}"
225,"public  void sort( int[] data )
{
    for (int i = 0; ++i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
226,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length % 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
227,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j != i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
228,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1;) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
229,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = --temp;
            }
        }
    }
}"
230,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j * 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
231,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j-- - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
232,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
233,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; true; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
234,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j * 1];
                data[j - 1] = temp;
            }
        }
    }
}"
235,"public  void sort( int[] data )
{
    for (int i = 0; i == data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
236,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i--; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
237,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j / 1] = temp;
            }
        }
    }
}"
238,"public  void sort( int[] data )
{
    for (int i = 0; i >= data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
239,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
240,"public  void sort( int[] data )
{
    for (int i = 0; i-- < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
241,"public  void sort( int[] data )
{
    for (int i = 0; ~i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
242,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j-- > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
243,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
        }
    }
}"
244,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (!(data[j] < data[j - 1])) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
245,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
            }
        }
    }
}"
246,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j-- - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
247,"public  void sort( int[] data )
{
    for (int i = 0; i < ~data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
248,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; ++j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
249,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j / 1];
                data[j - 1] = temp;
            }
        }
    }
}"
250,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[++j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
251,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length / 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
252,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j++] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
253,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[--j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
254,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = -temp;
            }
        }
    }
}"
255,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (true) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
256,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j <= i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
257,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i;  ) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
258,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[-j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
259,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j + 1];
                data[j - 1] = temp;
            }
        }
    }
}"
260,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[~j - 1] = temp;
            }
        }
    }
}"
261,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[~j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
262,"public  void sort( int[] data )
{
    for (int i = 0; i != data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
263,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j++ > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
264,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j == i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
265,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i++; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
266,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[~j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
267,"public  void sort( int[] data )
{
    for (int i = 0; i > data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
268,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j < i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
269,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > ~i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
270,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[-j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
271,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1;  ) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
272,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > --i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
273,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length * 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
274,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > ++i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
275,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j - 1] = temp;
            }
        }
    }
}"
276,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; ~j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
277,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j % 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
278,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j] = temp;
            }
        }
    }
}"
279,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; !(j > i); --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
280,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i--) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
281,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j >= i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
282,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j + 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
283,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = ++temp;
            }
        }
    }
}"
284,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] >= data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
285,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[++j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
286,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[++j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
287,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j * 1] = temp;
            }
        }
    }
}"
288,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (false) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
289,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[~j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
290,"public  void sort( int[] data )
{
}"
291,"public  void sort( int[] data )
{
    for (int i = 0; !(i < data.length - 1); i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
292,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j--];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
293,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j % 1];
                data[j - 1] = temp;
            }
        }
    }
}"
294,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp--;
            }
        }
    }
}"
295,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j++ - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
296,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j--] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
297,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[~j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
298,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; --j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
299,"public  void sort( int[] data )
{
    for (int i = 0; i++ < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
300,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j / 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
301,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
302,"public  void sort( int[] data )
{
    for (int i = 0; i < data.length - 1; i++) {
        for (int j = data.length - 1; j > i; --j) {
            if (data[j] < data[j++ - 1]) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}"
303,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
304,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > --maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
305,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c-- );
        }
    }
    return position;
}"
306,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
307,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position = Character.charCount( c );
            }
        }
    }
    return position;
}"
308,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
309,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos-- < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
310,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( currentPosition );
    return newPosition < maxPosition;
}"
311,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( currentPosition );
    return ~newPosition < maxPosition;
}"
312,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
313,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m >= c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
314,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && false) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
315,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c-- ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
316,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos > maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
317,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position-- );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
318,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && !(position < maxPosition)) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
319,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (!retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
320,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= ~Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
321,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (++c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
322,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
323,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
324,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (false && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
325,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c++ <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
326,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, ~currentPosition );
}"
327,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (true) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
328,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count++;
}"
329,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims ^ position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
330,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
331,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position++;
}"
332,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < ++maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
333,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c != maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
334,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position /= Character.charCount( c );
        }
    }
    return position;
}"
335,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) <= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
336,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c++ > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
337,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos++ );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
338,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( -currentPosition );
    return newPosition < maxPosition;
}"
339,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i >= count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
340,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( ++c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
341,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
342,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition++ >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
343,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (!(m < c)) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
344,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c++ <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
345,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c != Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
346,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (true) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
347,"public  java.lang.String nextToken()
{
    currentPosition = newPosition > 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
348,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition++ : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
349,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
350,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < ~c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
351,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( currentPosition );
    return newPosition >= maxPosition;
}"
352,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c < Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
353,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( ~c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
354,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (!(currentPosition >= maxPosition)) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
355,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] == codePoint) {
            return true;
        }
    }
    return false;
}"
356,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i++) {
        if (true) {
            return true;
        }
    }
    return false;
}"
357,"private  int scanToken( int startPos )
{
    int position = startPos--;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
358,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
359,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
            }
        }
    }
    return position;
}"
360,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
    }
    return position;
}"
361,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position = Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
362,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i %= Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
363,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[~count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
364,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return 0;
}"
365,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
366,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( --c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
367,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition++) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
368,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
369,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( --currpos );
        count++;
    }
    return count;
}"
370,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; ++i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
371,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
    }
    return position;
}"
372,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[--i] == codePoint) {
            return true;
        }
    }
    return false;
}"
373,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || false) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
374,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition-- );
    return str.substring( start, currentPosition );
}"
375,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < ~maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
376,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( ~c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
377,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition--) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
378,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) != 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
379,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
    }
}"
380,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( currentPosition );
    return true;
}"
381,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( --currentPosition );
    return newPosition < maxPosition;
}"
382,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c != maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
383,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (!(position < maxPosition)) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
384,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (true && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
385,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( --currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
386,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition++) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
387,"private  void setMaxDelimCodePoint()
{
    if (!(delimiters == null)) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
388,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && true) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
389,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (!(c > maxDelimCodePoint) || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
390,"public StringTokenizer( java.lang.String str, java.lang.String delim, boolean returnDelims )
{
    currentPosition = 0;
    newPosition = -1;
    delimsChanged = false;
    this.str = str;
    maxPosition = str.length();
    delimiters = delim;
    retDelims = returnDelims;
    setMaxDelimCodePoint();
}"
391,"public StringTokenizer( java.lang.String str, java.lang.String delim, boolean returnDelims )
{
    currentPosition = 0;
    newPosition = -1;
    delimsChanged = false;
    maxPosition = str.length();
    delimiters = delim;
    retDelims = returnDelims;
    setMaxDelimCodePoint();
}"
392,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c >= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
393,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= --maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
394,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (false) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
395,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition <= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
396,"public  java.lang.String nextToken()
{
    currentPosition = ~newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
397,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( --c );
            }
        }
    }
    return position;
}"
398,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( currentPosition );
    return newPosition != maxPosition;
}"
399,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
400,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( ~i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
401,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition--) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
402,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position--;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
403,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c == maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
404,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; true; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
405,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == ~position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
406,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) == 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
407,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( --c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
408,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i--) {
        if (delimiterCodePoints[i] == codePoint) {
            return true;
        }
    }
    return false;
}"
409,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( currentPosition );
    return newPosition > maxPosition;
}"
410,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (++c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
411,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] == ++codePoint) {
            return true;
        }
    }
    return false;
}"
412,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (!(c <= maxDelimCodePoint) && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
413,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c-- <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
414,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( --currentPosition );
    return str.substring( start, currentPosition );
}"
415,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
416,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (true && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
417,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (!(c > maxDelimCodePoint || delimiters.indexOf( c ) < 0)) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
418,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
419,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (--c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
420,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = 1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
421,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = ~m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
422,"public  java.lang.String nextToken()
{
    currentPosition = newPosition-- >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
423,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position <= maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
424,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (--c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
425,"public  java.lang.String nextToken( java.lang.String delim )
{
    delimiters = delim;
    delimsChanged = true;
    setMaxDelimCodePoint();
    return nextToken();
}"
426,"public  java.lang.String nextToken( java.lang.String delim )
{
    delimiters = delim;
    delimsChanged = true;
    return nextToken();
}"
427,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint && !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
428,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c >= maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
429,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c++ ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
430,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j /= Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
431,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c++ ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
432,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i++) {
        if (!(delimiterCodePoints[i] == codePoint)) {
            return true;
        }
    }
    return false;
}"
433,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims ^ startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
434,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( -currpos );
        count++;
    }
    return count;
}"
435,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && ~startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
436,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( -currentPosition );
    return str.substring( start, currentPosition );
}"
437,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= ~maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
438,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
439,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (~c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
440,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c-- <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
441,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
442,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
443,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
444,"public  java.lang.String nextToken( java.lang.String delim )
{
    delimsChanged = true;
    setMaxDelimCodePoint();
    return nextToken();
}"
445,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i--, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
446,"public  java.lang.String nextToken( java.lang.String delim )
{
    delimiters = delim;
    delimsChanged = true;
    setMaxDelimCodePoint();
    return """";
}"
447,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint++ && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
448,"private  int scanToken( int startPos )
{
    int position = ~startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
449,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c < maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
450,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( ~position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
451,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint ^ delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
452,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition++ );
    return str.substring( start, currentPosition );
}"
453,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; ~i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
454,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c++ > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
455,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i == delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
456,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c--;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
457,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < --maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
458,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && ++position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
459,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos >= maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
460,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( ~position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
461,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position >= maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
462,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos++ >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
463,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position++ );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
464,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
             ;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
465,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                 ;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
466,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m++;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
467,"private  void setMaxDelimCodePoint()
{
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
468,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position-- );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
469,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (~m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
470,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c < Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
471,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (true) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
472,"public  java.lang.String nextToken()
{
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
473,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c < maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
474,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( --i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
475,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos == maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
476,"public  java.lang.String nextToken()
{
    currentPosition = newPosition != 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
477,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
478,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c != maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
479,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < --maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
480,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
481,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position -= Character.charCount( c );
        }
    }
    return position;
}"
482,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
483,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c++ ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
484,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position-- );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
485,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c++ >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
486,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (~c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
487,"public  java.lang.String nextToken()
{
    currentPosition = newPosition <= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
488,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c < maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
489,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c >= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
490,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c == Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
491,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( -position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
492,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( --i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
493,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > ++maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
494,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( ++i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
495,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position *= Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
496,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i <= delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] == codePoint) {
            return true;
        }
    }
    return false;
}"
497,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c >= maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
498,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( ~c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
499,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position++ < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
500,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] == --codePoint) {
            return true;
        }
    }
    return false;
}"
501,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (--c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
502,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position-- );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
503,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; ~i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
504,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c++ );
            }
        }
    }
    return position;
}"
505,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (~c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
506,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position--;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
507,"public  java.lang.String nextToken()
{
    currentPosition = newPosition++ >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
508,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos++ < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
509,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (++currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
510,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (!(currpos >= maxPosition)) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
511,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos > maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
512,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition++) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
513,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( ++c );
        }
    }
    return position;
}"
514,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (!(c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0)) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
515,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( -j );
            delimiterCodePoints[i] = c;
        }
    }
}"
516,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint-- && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
517,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint ^ isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
518,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos != position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
519,"public  java.lang.String nextToken()
{
    currentPosition = ++newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
520,"public StringTokenizer( java.lang.String str, java.lang.String delim, boolean returnDelims )
{
    currentPosition = 0;
    newPosition = -1;
    delimsChanged = false;
    this.str = str;
    maxPosition = str.length();
    delimiters = delim;
    setMaxDelimCodePoint();
}"
521,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (~c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
522,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > --maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
523,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c >= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
524,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return ~position;
}"
525,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= ~maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
526,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c >= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
527,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( -position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
528,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return ~position;
}"
529,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
530,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( currentPosition );
    return false;
}"
531,"private  boolean isDelimiter( int codePoint )
{
    return false;
}"
532,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && false) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
533,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = ++m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
534,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i++) {
        if (false) {
            return true;
        }
    }
    return false;
}"
535,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (false || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
536,"public  java.lang.String nextToken()
{
    currentPosition = false && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
537,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition--;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
538,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && true) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
539,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition-- );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
540,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < --c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
541,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) < 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
542,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c++ <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
543,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= ~Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
544,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j = Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
545,"public  boolean hasMoreElements()
{
    return hasMoreTokens();
}"
546,"public  boolean hasMoreElements()
{
    return false;
}"
547,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i = Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
548,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = ~c;
        }
    }
}"
549,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
         ;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
550,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && true) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
551,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( --c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
552,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) > 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
553,"private  void setMaxDelimCodePoint()
{
    if (true) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
554,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; ++i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
555,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c++ )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
556,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
557,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position-- );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
558,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= ++maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
559,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (++currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
560,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
             ;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
561,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > ~maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
562,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition-- );
}"
563,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i++] == codePoint) {
            return true;
        }
    }
    return false;
}"
564,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint++ || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
565,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position++ );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
566,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= ++maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
567,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( ++c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
568,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return ~count;
}"
569,"public StringTokenizer( java.lang.String str, java.lang.String delim, boolean returnDelims )
{
    newPosition = -1;
    delimsChanged = false;
    this.str = str;
    maxPosition = str.length();
    delimiters = delim;
    retDelims = returnDelims;
    setMaxDelimCodePoint();
}"
570,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < ~delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] == codePoint) {
            return true;
        }
    }
    return false;
}"
571,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
572,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count--];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
573,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
574,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m != c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
575,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( ++c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
576,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( ~i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
577,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( ++j );
            delimiterCodePoints[i] = c;
        }
    }
}"
578,"public  boolean hasMoreTokens()
{
    return newPosition < maxPosition;
}"
579,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position-- < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
580,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
    }
    return count;
}"
581,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
582,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition != maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
583,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos-- );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
584,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j -= Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
585,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c == maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
586,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m <= c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
587,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( currentPosition );
    return newPosition < ~maxPosition;
}"
588,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( --c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
589,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (true && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
590,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c == maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
591,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (!(c <= maxDelimCodePoint) && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
592,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( ~position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
593,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims || startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
594,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c++ )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
595,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (++c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
596,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] == codePoint) {
            return true;
        }
    }
    return true;
}"
597,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count--;
    }
    return count;
}"
598,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint ^ delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
599,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c-- )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
600,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c-- > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
601,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint ^ isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
602,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (!(currpos < maxPosition)) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
603,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition--) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
604,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[~i] == codePoint) {
            return true;
        }
    }
    return false;
}"
605,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
606,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length();) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
607,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position > maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
608,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < ~count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
609,"public StringTokenizer( java.lang.String str, java.lang.String delim, boolean returnDelims )
{
    currentPosition = 0;
    newPosition = -1;
    delimsChanged = false;
    this.str = str;
    delimiters = delim;
    retDelims = returnDelims;
    setMaxDelimCodePoint();
}"
610,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position -= Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
611,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (--currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
612,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] > codePoint) {
            return true;
        }
    }
    return false;
}"
613,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition++;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
614,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( ~position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
615,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position %= Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
616,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i++) {
    }
    return false;
}"
617,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i == delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] == codePoint) {
            return true;
        }
    }
    return false;
}"
618,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( -currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
619,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= --maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
620,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i++ < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
621,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition++ );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
622,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( ~currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
623,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position++;
}"
624,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = --m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
625,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i != delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
626,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    return str.substring( start, currentPosition );
}"
627,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( currentPosition );
    return newPosition++ < maxPosition;
}"
628,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint++ && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
629,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count++; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
630,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
631,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start++, currentPosition );
}"
632,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint ^ delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
633,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint-- && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
634,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[++i] == codePoint) {
            return true;
        }
    }
    return false;
}"
635,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( currentPosition );
    return ++newPosition < maxPosition;
}"
636,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (--currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
637,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c <= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
638,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( ~currentPosition );
    return newPosition < maxPosition;
}"
639,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position++ );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
640,"public  java.lang.String nextToken()
{
    currentPosition = newPosition == 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
641,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    return position;
}"
642,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i-- );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
643,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition--) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
644,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position-- );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
645,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position++ );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
646,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0;; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
647,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
648,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c != maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
649,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return -position;
}"
650,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
651,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i-- < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
652,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && --startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
653,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; --i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
654,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition++) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
655,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= --maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
656,"public StringTokenizer( java.lang.String str, java.lang.String delim, boolean returnDelims )
{
    currentPosition = 0;
    newPosition = 1;
    delimsChanged = false;
    this.str = str;
    maxPosition = str.length();
    delimiters = delim;
    retDelims = returnDelims;
    setMaxDelimCodePoint();
}"
657,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos < maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
658,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c >= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
659,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            position += Character.charCount( c );
        }
    }
    return position;
}"
660,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c-- );
            }
        }
    }
    return position;
}"
661,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = -currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
662,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i > count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
663,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint-- || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
664,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c++;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
665,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
666,"public  java.lang.String nextToken( java.lang.String delim )
{
    delimiters = delim;
    setMaxDelimCodePoint();
    return nextToken();
}"
667,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (true) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
668,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition > maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
669,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = --c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
670,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( ~position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
671,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= --maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
672,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (++m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
673,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) > 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
674,"private  int scanToken( int startPos )
{
    int position = startPos;
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
675,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = ++c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
676,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
677,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition--) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
678,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i++ < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] == codePoint) {
            return true;
        }
    }
    return false;
}"
679,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= ++maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
680,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
681,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        count++;
    }
    return count;
}"
682,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition++ );
}"
683,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count--;
}"
684,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (--c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
685,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
686,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint++ || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
687,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && !(delimiters.indexOf( c ) >= 0)) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
688,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE || c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
689,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > ++maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
690,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position = Character.charCount( c );
        }
    }
    return position;
}"
691,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims || position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
692,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i /= Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
693,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (++c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
694,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && false) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
695,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (true) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
696,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; --i < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] == codePoint) {
            return true;
        }
    }
    return false;
}"
697,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] != codePoint) {
            return true;
        }
    }
    return false;
}"
698,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( currentPosition );
    return newPosition <= maxPosition;
}"
699,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i != delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] == codePoint) {
            return true;
        }
    }
    return false;
}"
700,"public  java.lang.String nextToken()
{
    currentPosition = --newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
701,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint ^ !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
702,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
703,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos++ == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
704,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start--, currentPosition );
}"
705,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c++ );
        }
    }
    return position;
}"
706,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c == Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
707,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition++;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
708,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = ~startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
709,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos <= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
710,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position -= Character.charCount( c );
            }
        }
    }
    return position;
}"
711,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, -currentPosition );
}"
712,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
713,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (!(c >= Character.MIN_HIGH_SURROGATE) && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
714,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return 0;
}"
715,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && true) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
716,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos != maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
717,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position == maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
718,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
719,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position-- < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
720,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!(!retDelims && position < maxPosition)) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
721,"public StringTokenizer( java.lang.String str, java.lang.String delim, boolean returnDelims )
{
    currentPosition = 0;
    newPosition = -1;
    delimsChanged = false;
    this.str = str;
    maxPosition = str.length();
    delimiters = delim;
    retDelims = returnDelims;
}"
722,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
         ;
    }
    return count;
}"
723,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < --maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
724,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (false || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
725,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (~c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
726,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c++ <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
727,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c++ )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
728,"public StringTokenizer( java.lang.String str, java.lang.String delim, boolean returnDelims )
{
    currentPosition = 0;
    newPosition = -1;
    delimsChanged = false;
    this.str = str;
    maxPosition = str.length();
    retDelims = returnDelims;
    setMaxDelimCodePoint();
}"
729,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j++ );
            delimiterCodePoints[i] = c;
        }
    }
}"
730,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position >= maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
731,"public  int countTokens()
{
    int count = 0;
    int currpos = ~currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
732,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( ~currentPosition );
    return str.substring( start, currentPosition );
}"
733,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
734,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position *= Character.charCount( c );
        }
    }
    return position;
}"
735,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i >= delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
736,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; !(i < delimiterCodePoints.length); i++) {
        if (delimiterCodePoints[i] == codePoint) {
            return true;
        }
    }
    return false;
}"
737,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
}"
738,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) > 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
739,"private  void setMaxDelimCodePoint()
{
    if (delimiters != null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
740,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i -= Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
741,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = --c;
        }
    }
}"
742,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( ~c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
743,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position *= Character.charCount( c );
            }
        }
    }
    return position;
}"
744,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( --c );
        }
    }
    return position;
}"
745,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i--] == codePoint) {
            return true;
        }
    }
    return false;
}"
746,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( ++c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
747,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
748,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( -c );
            }
        }
    }
    return position;
}"
749,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (~currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
750,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= ~maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
751,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position != maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
752,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( --j );
            delimiterCodePoints[i] = c;
        }
    }
}"
753,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (--c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
754,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (true || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
755,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c++;
        }
    }
}"
756,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < ++count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
757,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = -m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
758,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < --count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
759,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c-- <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
760,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (false && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
761,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( --c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
762,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (true || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
763,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m--;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
764,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < ~maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
765,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j *= Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
766,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] == codePoint--) {
            return true;
        }
    }
    return false;
}"
767,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count;) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
768,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos >= position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
769,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (true) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
770,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] <= codePoint) {
            return true;
        }
    }
    return false;
}"
771,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( currentPosition );
    return !(newPosition < maxPosition);
}"
772,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c-- <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
773,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[-count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
774,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( ~c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
775,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos-- );
        count++;
    }
    return count;
}"
776,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c++ <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
777,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length;  ) {
        if (delimiterCodePoints[i] == codePoint) {
            return true;
        }
    }
    return false;
}"
778,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (false && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
779,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (!(c <= maxDelimCodePoint) && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
780,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c > Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
781,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
782,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos <= maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
783,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
784,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || !(delimiters.indexOf( c ) < 0)) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
785,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( ~c );
        }
    }
    return position;
}"
786,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c != maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
787,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c++ )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
788,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position %= Character.charCount( c );
            }
        }
    }
    return position;
}"
789,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
790,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( -position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
791,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (true) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
792,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (!(c <= maxDelimCodePoint && isDelimiter( c ))) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
793,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= ++maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
794,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
795,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c-- )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
796,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c--) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
797,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
798,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position--;
}"
799,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( ~j );
            delimiterCodePoints[i] = c;
        }
    }
}"
800,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && false) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
801,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
802,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (--m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
803,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && !(c <= Character.MAX_LOW_SURROGATE)) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
804,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (false) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
805,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint || isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
806,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
807,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < ~maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
808,"public  java.lang.String nextToken()
{
    currentPosition = newPosition < 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
809,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c--;
        }
    }
}"
810,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (true && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
811,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c-- );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
812,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c++ );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
813,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( -c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
814,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( ++currentPosition );
    return str.substring( start, currentPosition );
}"
815,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i > delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] == codePoint) {
            return true;
        }
    }
    return false;
}"
816,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; --i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
817,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count++];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
818,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && ~position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
819,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length;) {
        if (delimiterCodePoints[i] == codePoint) {
            return true;
        }
    }
    return false;
}"
820,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? ~newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
821,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (--c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
822,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = -startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
823,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
        }
    }
}"
824,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( ++currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
825,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count--;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
826,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (true) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
827,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( currentPosition );
    return newPosition < maxPosition++;
}"
828,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( currentPosition-- );
    return newPosition < maxPosition;
}"
829,"public  java.lang.String nextToken()
{
    currentPosition = !(newPosition >= 0) && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
830,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && false) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
831,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( currentPosition );
    return newPosition < --maxPosition;
}"
832,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (++c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
833,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i *= Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
834,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (false) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
835,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( currentPosition );
    return newPosition == maxPosition;
}"
836,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition--;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
837,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= ~maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
838,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (!(c > maxDelimCodePoint) || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
839,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint++ && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
840,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i-- < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] == codePoint) {
            return true;
        }
    }
    return false;
}"
841,"public  int countTokens()
{
    int count = 0;
    int currpos = -currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
842,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( ~c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
843,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( currentPosition );
    return newPosition-- < maxPosition;
}"
844,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( -c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
845,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
846,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( ++currentPosition );
    return newPosition < maxPosition;
}"
847,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( currentPosition );
    return newPosition < maxPosition--;
}"
848,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( -i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
849,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos < position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
850,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (++currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
851,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (true) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
852,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) == 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
853,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count--; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
854,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c-- ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
855,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i++ < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
856,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos-- == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
857,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( ~currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
858,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( ~position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
859,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
860,"private  int scanToken( int startPos )
{
    int position = -startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
861,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition-- >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
862,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint || isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
863,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( -c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
864,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c < maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
865,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= ~maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
866,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
867,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; ~i < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] == codePoint) {
            return true;
        }
    }
    return false;
}"
868,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) != 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
869,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 ^ !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
870,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = ~currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
871,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c-- > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
872,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (true) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
873,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position++ );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
874,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i != count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
875,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
876,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] == codePoint++) {
            return true;
        }
    }
    return false;
}"
877,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (~currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
878,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
879,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (--position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
880,"private  int skipDelimiters( int startPos )
{
    if (delimiters != null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
881,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position /= Character.charCount( c );
            }
        }
    }
    return position;
}"
882,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= ++maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
883,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == --position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
884,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (!isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
885,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c != maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
886,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = ++c;
        }
    }
}"
887,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (++position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
888,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return """";
}"
889,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (~c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
890,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (true && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
891,"public  java.lang.String nextToken()
{
    currentPosition = !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
892,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m++ < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
893,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) <= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
894,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position <= maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
895,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
896,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos-- >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
897,"private  int scanToken( int startPos )
{
    int position = startPos++;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
898,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c-- <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
899,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position++ < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
900,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
901,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( -position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
902,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; !(i < delimiters.length()); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
903,"public StringTokenizer( java.lang.String str, java.lang.String delim, boolean returnDelims )
{
    currentPosition = 0;
    newPosition = -1;
    this.str = str;
    maxPosition = str.length();
    delimiters = delim;
    retDelims = returnDelims;
    setMaxDelimCodePoint();
}"
904,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
905,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[~i] = c;
        }
    }
}"
906,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
907,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j-- );
            delimiterCodePoints[i] = c;
        }
    }
}"
908,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos == maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
909,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j %= Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
910,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i <= delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
911,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE ^ c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
912,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return -position;
}"
913,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
914,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (!(c > maxDelimCodePoint || !isDelimiter( c ))) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
915,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) <= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
916,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
917,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c-- )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
918,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position--;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
919,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos++;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
920,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( ~c );
            }
        }
    }
    return position;
}"
921,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( -currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
922,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint && delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
923,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( ~currpos );
        count++;
    }
    return count;
}"
924,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return 0;
}"
925,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint-- && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
926,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (!hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
927,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (!(retDelims && startPos == position)) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
928,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (true) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
929,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
930,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( ~c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
931,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
932,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos > position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
933,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
934,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos--;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
935,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= --maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
936,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && ++startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
937,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < ++c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
938,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c == maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
939,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m > c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
940,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position > maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
941,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < ++maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
942,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( -start, currentPosition );
}"
943,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = ~c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
944,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (false && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
945,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( ++c );
            }
        }
    }
    return position;
}"
946,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
947,"public  java.lang.String nextToken()
{
    currentPosition = true && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
948,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c < maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
949,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] < codePoint) {
            return true;
        }
    }
    return false;
}"
950,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos <= position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
951,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( -position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
952,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) != 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
953,"public StringTokenizer( java.lang.String str, java.lang.String delim, boolean returnDelims )
{
    currentPosition = 0;
    delimsChanged = false;
    this.str = str;
    maxPosition = str.length();
    delimiters = delim;
    retDelims = returnDelims;
    setMaxDelimCodePoint();
}"
954,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (true) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
955,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position++ );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
956,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i-- );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
957,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position != maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
958,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < ++maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
959,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] == codePoint) {
            return false;
        }
    }
    return false;
}"
960,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m-- < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
961,"public  boolean hasMoreElements()
{
    return true;
}"
962,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
963,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( currentPosition );
    return --newPosition < maxPosition;
}"
964,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c-- )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
965,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i++ );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
966,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (~currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
967,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
        }
    }
    return position;
}"
968,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (++c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
969,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && ~c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
970,"public  java.lang.String nextToken()
{
    currentPosition = !(newPosition >= 0 && !delimsChanged) ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
971,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || true) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
972,"private  int skipDelimiters( int startPos )
{
    if (true) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
973,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition == maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
974,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (true) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
975,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c == maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
976,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i == count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
977,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = -c;
        }
    }
}"
978,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
979,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c > Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
980,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( ~c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
981,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] >= codePoint) {
            return true;
        }
    }
    return false;
}"
982,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position == maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
983,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c == maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
984,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m == c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
985,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c != Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
986,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint-- || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
987,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( ++i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
988,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? -newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
989,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (!(c <= maxDelimCodePoint) && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
990,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( -c );
        }
    }
    return position;
}"
991,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && !(startPos == position)) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
992,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    return count;
}"
993,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && --position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
994,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position--;
}"
995,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; !(i < count); i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
996,"private  int skipDelimiters( int startPos )
{
    if (!(delimiters == null)) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
997,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( ~start, currentPosition );
}"
998,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos != maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
999,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c-- ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
1000,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && true) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1001,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
        }
    }
    return position;
}"
1002,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c < maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1003,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (true) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1004,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i <= count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
1005,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (~c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1006,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i >= delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] == codePoint) {
            return true;
        }
    }
    return false;
}"
1007,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position /= Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1008,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) == 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
1009,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1010,"private  int skipDelimiters( int startPos )
{
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
1011,"public StringTokenizer( java.lang.String str, java.lang.String delim, boolean returnDelims )
{
    currentPosition = 0;
    newPosition = -1;
    delimsChanged = false;
    this.str = str;
    maxPosition = str.length();
    delimiters = delim;
    retDelims = !returnDelims;
    setMaxDelimCodePoint();
}"
1012,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( ++currpos );
        count++;
    }
    return count;
}"
1013,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint || delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1014,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( currentPosition++ );
    return newPosition < maxPosition;
}"
1015,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position %= Character.charCount( c );
        }
    }
    return position;
}"
1016,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && --c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
1017,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= --maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1018,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( ~c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
1019,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[--count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
1020,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
1021,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; ++i < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] == codePoint) {
            return true;
        }
    }
    return false;
}"
1022,"public  boolean hasMoreTokens()
{
    newPosition = skipDelimiters( currentPosition );
    return newPosition < ++maxPosition;
}"
1023,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= ~maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1024,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position--) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1025,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition < maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
1026,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (~position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1027,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[++count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
1028,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos++ );
        count++;
    }
    return count;
}"
1029,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (true) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
1030,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 || !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
1031,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition-- : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
1032,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c++) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
1033,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i > delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
1034,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i++ );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
1035,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( ++c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
1036,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (true) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
1037,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( --c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1038,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (false && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
1039,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( ++c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1040,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (true) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
1041,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (true) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1042,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1043,"private  int skipDelimiters( int startPos )
{
    if (delimiters == null) {
        throw new java.lang.NullPointerException();
    }
    int position = startPos;
    while (!retDelims && position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c > maxDelimCodePoint || delimiters.indexOf( c ) < 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c > ~maxDelimCodePoint || !isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    return position;
}"
1044,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c-- >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
1045,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint++ && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1046,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == ++position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1047,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (!(c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0)) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1048,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (++c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1049,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
1050,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint-- && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1051,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && !(delimiters.indexOf( c ) >= 0)) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1052,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
1053,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint || delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1054,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= ++maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1055,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return -count;
}"
1056,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (!(c <= maxDelimCodePoint && isDelimiter( c ))) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1057,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = -c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
1058,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( -i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
1059,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (--c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1060,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (!(c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE)) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
1061,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position++) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1062,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && ++c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
1063,"public  int countTokens()
{
    int count = 0;
    int currpos = currentPosition;
    while (currpos < maxPosition) {
        currpos = skipDelimiters( currpos );
        if (--currpos >= maxPosition) {
            break;
        }
        currpos = scanToken( currpos );
        count++;
    }
    return count;
}"
1064,"public  java.lang.String nextToken()
{
    currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters( currentPosition );
    delimsChanged = false;
    newPosition = -1;
    if (currentPosition >= maxPosition++) {
        throw new java.util.NoSuchElementException();
    }
    int start = currentPosition;
    currentPosition = scanToken( currentPosition );
    return str.substring( start, currentPosition );
}"
1065,"private  void setMaxDelimCodePoint()
{
    if (delimiters == null) {
        maxDelimCodePoint = 0;
        return;
    }
    int m = 0;
    int c;
    int count = 0;
    for (int i = 0; i-- < delimiters.length(); i += Character.charCount( c )) {
        c = delimiters.charAt( i );
        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {
            c = delimiters.codePointAt( i );
            hasSurrogates = true;
        }
        if (m < c) {
            m = c;
        }
        count++;
    }
    maxDelimCodePoint = m;
    if (hasSurrogates) {
        delimiterCodePoints = new int[count];
        for (int i = 0, j = 0; i < count; i++, j += Character.charCount( c )) {
            c = delimiters.codePointAt( j );
            delimiterCodePoints[i] = c;
        }
    }
}"
1066,"private  int scanToken( int startPos )
{
    int position = startPos;
    while (position < maxPosition) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                break;
            }
            position++;
        } else {
            int c = str.codePointAt( -position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                break;
            }
            position += Character.charCount( c );
        }
    }
    if (retDelims && startPos == position) {
        if (!hasSurrogates) {
            char c = str.charAt( position );
            if (c <= maxDelimCodePoint && delimiters.indexOf( c ) >= 0) {
                position++;
            }
        } else {
            int c = str.codePointAt( position );
            if (c <= maxDelimCodePoint && isDelimiter( c )) {
                position += Character.charCount( c );
            }
        }
    }
    return position;
}"
1067,"private  boolean isDelimiter( int codePoint )
{
    for (int i = 0; i < delimiterCodePoints.length; i++) {
        if (delimiterCodePoints[i] == ~codePoint) {
            return true;
        }
    }
    return false;
}"
1068,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1069,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = --We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1070,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0-- >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1071,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e >= 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1072,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15-- )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1073,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF++ == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1074,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request++ > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1075,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e <= 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1076,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e++ > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1077,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( -abs(We1_BA_DEF_ev_ctr3) - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1078,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) * ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1079,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e == 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1080,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0-- >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1081,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2-- * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1082,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0++ >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1083,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) + ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1084,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( ++We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1085,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF <= 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1086,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && --error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1087,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e++ > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1088,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) > 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1089,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && ++error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1090,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && --confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1091,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3-- - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1092,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF++ > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1093,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e < 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1094,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request <= 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1095,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e <= 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1096,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e-- > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1097,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF++ == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1098,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 > ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1099,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1100,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( --We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1101,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request-- > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1102,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e != 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1103,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF != 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1104,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( --ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1105,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request++ == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1106,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e++ == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1107,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e-- == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1108,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e <= 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1109,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF != 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1110,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0++ >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1111,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * --We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1112,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF-- == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1113,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15++ )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1114,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3++ - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1115,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF <= 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1116,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 * ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1117,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e >= 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1118,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e-- == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1119,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1120,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == --We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1121,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( --We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1122,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e == 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1123,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e < 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1124,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * abs(We1_BA_DEF_ev_ctr2) - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1125,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e++ == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1126,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( --confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1127,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e++ == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1128,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = -abs(We1_BA_DEF_ev_ctr2) * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1129,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e++ > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1130,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ++ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1131,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request-- == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1132,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) * ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1133,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF++ == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1134,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 > ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1135,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * ++We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1136,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 == ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1137,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e >= 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1138,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e != 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1139,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e <= 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1140,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && --error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1141,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF-- > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1142,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e != 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1143,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 == ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1144,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev++ ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1145,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF >= 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1146,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF < We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1147,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 <= 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1148,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e < 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1149,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 > ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1150,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && ++confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1151,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( ++We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1152,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == ++We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1153,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF++ == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1154,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) + ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1155,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF++ > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1156,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e-- > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1157,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF-- == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1158,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( ++confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1159,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e == 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1160,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev-- ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1161,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e-- == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1162,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( --We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1163,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 % ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1164,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e == 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1165,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && --confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1166,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e-- > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1167,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( abs(We1_BA_DEF_ev_ctr3) - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1168,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e-- > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1169,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( ++We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1170,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 / ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1171,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e++ > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1172,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e > 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1173,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 == ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1174,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF-- > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1175,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request != 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1176,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF-- == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1177,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if (Clip_15-- == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1178,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF <= We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1179,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF > 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1180,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e <= 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1181,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if (Clip_15++ == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1182,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF-- == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1183,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
    	We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 % ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1184,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = abs(We1_BA_DEF_ev_ctr2) * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1185,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * (-abs(We1_BA_DEF_ev_ctr2)) - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1186,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e < 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1187,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2++ - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1188,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e < 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1189,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e != 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1190,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e >= 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1191,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 - We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1192,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2++ * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1193,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e != 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1194,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF < 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1195,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2-- - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1196,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e <= 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1197,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && ++error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1198,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF <= 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1199,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( --We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1200,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 > 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1201,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) >= 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1202,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = ++We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1203,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && ++confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1204,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF != 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1205,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 - We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1206,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e >= 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1207,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 + ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1208,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 >= 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1209,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 - We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1210,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( ++We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1211,"public void main()
{
	 int We1_BA_DEF_ev = 0;
	 int We1_BA_DEF ;
	We1_BA_DEF_ev_ctr1 ++ ;
	We1_BA_DEF_ev_ctr0 ++ ;
	if ( 0 != AU8.We2_Clip15_OUT )
	{
		if (0 != Clip_15 )
		{
			AU8.We2_Clip15_OUT = 0;
			AU8.We3_Clip15_ON = 1;
			AU8.We9_DEF_OUT = 1;
			We1_BA_DEF_ev_ctr0 = 0;
			AU8.We11_BLINK_OUT = 1;
			control_led = 0;
        }
    }
	else
	{
		We1_BA_DEF = We1_BA_DEF_ev_ctr2 * We1_BA_DEF_ev_ctr2 - ( We1_BA_DEF_ev_ctr3 - 1000);
		if ( ! ( We1_BA_DEF == We1_BA_DEF_ev ))
		{
			We1_BA_DEF_ev_ctr2 = 0;
        }
		if ( 0 != AU8.We3_Clip15_ON )
		{
			if ( Clip_15 == 0)
			{
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					AU8.We11_BLINK_OUT = 0;
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						AU8.We12_BLINK_ON = 0;
                    }
                }
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					Exception_handler ();
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						AU8.We8_BE_CONFIRM_OUT = 0;
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							AU8.We9_DEF_OUT = 0;
                        }
                    }
                }
				AU8.We3_Clip15_ON = 0;
				request = 0;
				control_led = 0;
				AU8.We2_Clip15_OUT = 1;
            }
			else
			{
				if ( 0 != AU8.We5_BE_HANDLING )
				{
					if (( We1_BA_DEF_ev_ctr1 >= ((  int ) 1000 )) && ( confirmation_e == 0 ) && ( ControlElement_DEF == 0 ))
					{
						Exception_handler ();
						request = 0;
						AU8.We9_DEF_OUT = 1;
                    }
					else
					{
						if ( 0 != AU8.We6_BE_CONFIRM_ON )
						{
							if ( ControlElement_DEF == 0)
							{
								AU8.We6_BE_CONFIRM_ON = 0;
								AU8.We7_BE_LOSGELASSEN = 1;
                            }
                        }
						else
						{
							if ( 0 != AU8.We7_BE_LOSGELASSEN )
							{
								if ( ControlElement_DEF > 0)
								{
									Exception_handler ();
									request = 0;
									AU8.We8_BE_CONFIRM_OUT = 1;
                                }
                            }
                        }
                    }
                }
				else
				{
					if ( 0 != AU8.We8_BE_CONFIRM_OUT )
					{
						if ( ControlElement_DEF == 0)
						{
							AU8.We8_BE_CONFIRM_OUT = 0;
							AU8.We9_DEF_OUT = 1;
                        }
                    }
					else
					{
						if ( 0 != AU8.We9_DEF_OUT )
						{
							if ( ControlElement_DEF > 0)
							{
								AU8.We9_DEF_OUT = 0;
								request = 1;
								We1_BA_DEF_ev_ctr1 = 0;
								AU8.We5_BE_HANDLING = 1;
								AU8.We6_BE_CONFIRM_ON = 1;
                            }
                        }
                    }
                }
				if ( 0 != AU8.We11_BLINK_OUT )
				{
					if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e > 0 && confirmation_e > 0)
					{
						AU8.We11_BLINK_OUT = 0;
                    }
					else
					{
						if ( request > 0 && ( error_e == 0))
						{
							AU8.We11_BLINK_OUT = 0;
						}
                    }
                }
				else
				{
					if ( 0 != AU8.We12_BLINK_ON )
					{
						if (( request == 0) && ( error_e == 0))
						{
							AU8.We12_BLINK_ON = 0;
                        }
						else
						{
							if (( We1_BA_DEF_ev_ctr0 >= ((  int ) 3250 )) && error_e <= 0 && confirmation_e > 0)
							{
								AU8.We12_BLINK_ON = 0;
                            }
                        }
                    }
                }
            }
        }
		else
		{
			AU8.We2_Clip15_OUT = 1;
        }
    }
	if ( We1_BA_DEF_ev_ctr2 + We1_BA_DEF_ev_ctr3 + We1_BA_DEF_ev_ctr5 == 1024)
	{
		We1_BA_DEF_ev_ctr2 = 32767;
    }
	else
	{
		if (( We1_BA_DEF_ev_ctr2 ) - ( We1_BA_DEF_ev_ctr3 ) - ( We1_BA_DEF_ev_ctr5 ) == 1024)
		{
			We1_BA_DEF_ev_ctr2 = - 32768;
        }
		else
			We1_BA_DEF_ev_ctr2 = 32767;
    }
}"
1212,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1213,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff == 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1214,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (false) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1215,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon++) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1216,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x--;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1217,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (++diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1218,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = N;
    }
    r = x;
    mResult = r;
    return r;
}"
1219,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) != mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1220,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1221,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * ++x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1222,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs( --diff ) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1223,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x * N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1224,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x-- - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1225,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = -x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1226,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff == 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1227,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs( diff-- ) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1228,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 1) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1229,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) * 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1230,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = ++x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1231,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    r = x;
    mResult = r;
    return r;
}"
1232,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (true) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1233,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r--;
    return r;
}"
1234,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x++ - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1235,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = --x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1236,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) >= mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1237,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1238,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1239,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x / x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1240,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) + 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1241,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x - x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1242,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = -r;
    return r;
}"
1243,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff != 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1244,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff-- > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1245,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / -2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1246,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r--;
}"
1247,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x % N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1248,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = ++x;
    mResult = r;
    return r;
}"
1249,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + --x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1250,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N--;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1251,"public  void setEpsilon( double epsilon )
{
    this.mEpsilon = epsilon;
}"
1252,"public  void setEpsilon( double epsilon )
{
    this.mEpsilon = -epsilon;
}"
1253,"public  double sqrt( double N )
{
    double x = N++;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1254,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x;
    }
    r = x;
    mResult = r;
    return r;
}"
1255,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (--M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1256,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x % x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1257,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = -x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1258,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x++ * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1259,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x % x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1260,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = m + x - 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1261,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x + N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1262,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff <= 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1263,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1264,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff >= 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1265,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (false) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1266,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 0;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1267,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (--diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1268,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x--) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1269,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1270,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (++M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1271,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x / N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1272,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs( diff++ ) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1273,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return 0;
}"
1274,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m * x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1275,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m++ + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1276,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = M + x + 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1277,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) + 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1278,"public  double sqrt( double N )
{
    double x = N;
    double M = N--;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1279,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs( ++diff ) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1280,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (!(diff > 0)) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1281,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x + x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1282,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x - x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1283,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = --x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1284,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x++ * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1285,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m-- + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1286,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff-- < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1287,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M % x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1288,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m / x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1289,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x--;
    mResult = r;
    return r;
}"
1290,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = -x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1291,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) <= mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1292,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (-M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1293,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x++;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1294,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M++ + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1295,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x + x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1296,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 0;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1297,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x++) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1298,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > --mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1299,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) % 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1300,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x--) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1301,"public  void setEpsilon( double epsilon )
{
    this.mEpsilon = epsilon--;
}"
1302,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x / x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1303,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M * x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1304,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r++;
}"
1305,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) % 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1306,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (--m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1307,"public  double sqrt( double N )
{
    double x = N--;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1308,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1309,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = m + x;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1310,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1311,"public  void setEpsilon( double epsilon )
{
    this.mEpsilon = ++epsilon;
}"
1312,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1313,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (-m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1314,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x * N;
    }
    r = x;
    mResult = r;
    return r;
}"
1315,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x++ - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1316,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 1) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1317,"public  double sqrt( double N )
{
    double x = N;
    double M = -N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1318,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (true) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1319,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < -1) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1320,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon--) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1321,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (false) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1322,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x--;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1323,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = ++x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1324,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1325,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1326,"public  void setEpsilon( double epsilon )
{
    this.mEpsilon = --epsilon;
}"
1327,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = --x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1328,"public  double sqrt( double N )
{
    double x = -N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1329,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N++;
    }
    r = x;
    mResult = r;
    return r;
}"
1330,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) * 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1331,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M - x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1332,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * ++x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1333,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff != 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1334,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff >= 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1335,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff < 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1336,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x++;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1337,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = -x;
    mResult = r;
    return r;
}"
1338,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x++;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1339,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x++;
    mResult = r;
    return r;
}"
1340,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff > 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1341,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + ++x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1342,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M-- + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1343,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = -1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1344,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m % x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1345,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) - 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1346,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1347,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x--;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1348,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1349,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (++m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1350,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (--diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1351,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = -x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1352,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x-- - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1353,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (!(Math.abs( diff ) > mEpsilon)) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1354,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = ++x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1355,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff++ < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1356,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    mResult = r;
    return r;
}"
1357,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = -x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1358,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) < mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1359,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + --x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1360,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m - x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1361,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) == mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1362,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return -r;
}"
1363,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x-- * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1364,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1365,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + ++x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1366,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = M + x;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1367,"public  double sqrt( double N )
{
    double x = N;
    double M = N++;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1368,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1369,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x-- * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1370,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 0;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1371,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x++) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1372,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = ++r;
    return r;
}"
1373,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x + N;
    }
    r = x;
    mResult = r;
    return r;
}"
1374,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (!(diff < 0)) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1375,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x / N;
    }
    r = x;
    mResult = r;
    return r;
}"
1376,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = M + x - 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1377,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / -2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1378,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M / x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1379,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = ++x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1380,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r++;
    return r;
}"
1381,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > ++mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1382,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * --x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1383,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) - 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1384,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = --r;
    return r;
}"
1385,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = --x;
    mResult = r;
    return r;
}"
1386,"public  void setEpsilon( double epsilon )
{
}"
1387,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff++ > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1388,"public  void setEpsilon( double epsilon )
{
    this.mEpsilon = epsilon++;
}"
1389,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * --x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1390,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N++;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1391,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1392,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = --x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1393,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    return r;
}"
1394,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
    }
    r = x;
    mResult = r;
    return r;
}"
1395,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N--;
    }
    r = x;
    mResult = r;
    return r;
}"
1396,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > -1) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1397,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (++diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1398,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff <= 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1399,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = (m + x) / 2;
            }
        }
        diff = x * x % N;
    }
    r = x;
    mResult = r;
    return r;
}"
1400,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1401,"public  double sqrt( double N )
{
    double x = N;
    double M = N;
    double m = 1;
    double r = x;
    double diff = x * x - N;
    while (Math.abs(diff) > mEpsilon) {
        if (diff < 0) {
            m = x;
            x = (M + x) / 2;
        } else {
            if (diff > 0) {
                M = x;
                x = m + x + 2;
            }
        }
        diff = x * x - N;
    }
    r = x;
    mResult = r;
    return r;
}"
1402,"public static int main( int a, int b, int c ) {
	int mid;
	if (a < b) {
		if (c < b) {
			if (a < c) {
				mid = c;
			} else {
				mid = a;
			}
		} else {
			mid = b;
		}
	} else {
		if (c > b) {
			if (a > c) {
				mid = c;
			} else {
				mid = a;
			}
		} else {
			mid = b;
		}
	}
	return mid;
}"
1403,"public static int main( int a, int b, int c ) {
	int mid;
	if (a < b) {
		if (c < b) {
			if (a <= c) {
				mid = c;
			} else {
				mid = a;
			}
		} else {
			mid = b;
		}
	} else {
		if (c > b) {
			if (a > c) {
				mid = c;
			} else {
				mid = a;
			}
		} else {
			mid = b;
		}
	}
	return mid;
}"
1404,"public static int main( int a, int b, int c ) {
	int mid;
	if (a < b) {
		if (c <= b) {
			if (a < c) {
				mid = c;
			} else {
				mid = a;
			}
		} else {
			mid = b;
		}
	} else {
		if (c > b) {
			if (a > c) {
				mid = c;
			} else {
				mid = a;
			}
		} else {
			mid = b;
		}
	}
	return mid;
}"
1405,"public static int main( int a, int b, int c ) {
	int mid;
	if (a < b) {
		if (c < b) {
			if (a < c) {
				mid = c;
			} else {
				mid = a;
			}
		} else {
			mid = b;
		}
	} else {
		if (c >= b) {
			if (a > c) {
				mid = c;
			} else {
				mid = a;
			}
		} else {
			mid = b;
		}
	}
	return mid;
}"
1406,"public static int main( int a, int b, int c ) {
	int mid;
	if (a < b) {
		if (c < b) {
			if (a < c) {
				mid = c;
			} else {
				mid = a;
			}
		} else {
			mid = b;
		}
	} else {
		if (c > b) {
			if (a >= c) {
				mid = c;
			} else {
				mid = a;
			}
		} else {
			mid = b;
		}
	}
	return mid;
}"
1407,"public static int main( int a, int b, int c ) {
	int mid;
	if (a <= b) {
		if (c < b) {
			if (a < c) {
				mid = c;
			} else {
				mid = a;
			}
		} else {
			mid = b;
		}
	} else {
		if (c > b) {
			if (a > c) {
				mid = c;
			} else {
				mid = a;
			}
		} else {
			mid = b;
		}
	}
	return mid;
}"
1408,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1409,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian != 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1410,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + ++c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1411,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (false) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1412,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (false) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1413,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && !(a + c > b)) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1414,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b <= c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1415,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1416,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && false) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1417,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (true) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1418,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1419,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a * c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1420,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (!(trian == 1 && a + b > c)) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1421,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a / b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1422,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (++a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1423,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (false || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1424,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a - b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1425,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b - c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1426,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == -1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1427,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 0 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1428,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian % 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1429,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 != b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1430,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1431,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a++ + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1432,"public static  int classify( int a, int b, int c )
{
    int trian;
    if ((a <= 0 || b <= 0) != c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1433,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a - c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1434,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1435,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b / c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1436,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian <= 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1437,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (~a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1438,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (true) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1439,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if ((a + b < c || a + c < b) != b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1440,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c > a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1441,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (~b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1442,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (~a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1443,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 0 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1444,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1445,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a % c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1446,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c && a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1447,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian >= 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1448,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a > c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1449,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b - c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1450,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1451,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return -EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1452,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (!(a == c)) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1453,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b >= c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1454,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1455,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c < 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1456,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b == 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1457,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c != b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1458,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (true) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1459,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1460,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + --c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1461,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return ~SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1462,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b >= c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1463,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c++ > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1464,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + ~b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1465,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c <= b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1466,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a++ + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1467,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1468,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian <= 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1469,"public static  int classify( int a, int b, int c )
{
    int trian;
    if ((a <= 0 || b <= 0) && c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1470,"public static  int classify( int a, int b, int c )
{
    int trian;
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1471,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + ~c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1472,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || false || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1473,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c > 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1474,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c++) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1475,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1476,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b++) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1477,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian * 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1478,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c != b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1479,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && false) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1480,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || ++b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1481,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (false && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1482,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a <= b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1483,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1484,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a % b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1485,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian - 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1486,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + -2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1487,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (!(trian == 2 && a + c > b)) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1488,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a <= c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1489,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 == b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1490,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a - c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1491,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (--trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1492,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a * c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1493,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a--) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1494,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (++a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1495,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a-- <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1496,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || ~b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1497,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b > c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1498,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 0 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1499,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (--a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1500,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 1;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1501,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || ~b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1502,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian-- + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1503,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a != c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1504,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && --a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1505,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian != 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1506,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c == 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1507,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (++a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1508,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (false) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1509,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 1) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1510,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (--a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1511,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b < 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1512,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a-- == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1513,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1514,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c != a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1515,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c <= a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1516,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b-- || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1517,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
    }
    return INVALID;
}"
1518,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (true && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1519,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > ~c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1520,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return -ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1521,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian >= 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1522,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (false) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1523,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a++) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1524,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a - b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1525,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian <= 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1526,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian / 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1527,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && false) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1528,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == -1) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1529,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (true || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1530,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (!(a + b < c || a + c < b || b + c < a)) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1531,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (!(trian == 3 && b + c > a)) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1532,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a < b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1533,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a < 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1534,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + ~c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1535,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b * c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1536,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c != a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1537,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = --trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1538,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1539,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c < a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1540,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == --c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1541,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1542,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian >= 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1543,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (!(b == c)) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1544,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < ~b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1545,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (false) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1546,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (true || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1547,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (true || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1548,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + --c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1549,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a % c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1550,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian >= 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1551,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a == 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1552,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b % c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1553,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (!(trian == 1) && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1554,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    return INVALID;
}"
1555,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian - 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1556,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a-- + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1557,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a / c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1558,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b % c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1559,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a >= b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1560,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a / c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1561,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return 0;
            }
        }
    }
    return INVALID;
}"
1562,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = ~trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1563,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (~trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1564,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian <= 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1565,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b++ > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1566,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && --b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1567,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (--a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1568,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b++ + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1569,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + ++b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1570,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return 0;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1571,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == --b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1572,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (--b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1573,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || true || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1574,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (++trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1575,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a / b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1576,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == -3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1577,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b / c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1578,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1579,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a != 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1580,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1581,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a % b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1582,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c > b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1583,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && ~a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1584,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (!(a <= 0) || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1585,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian < 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1586,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + ~c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1587,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (true) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1588,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (false) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1589,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c--) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1590,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b < c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1591,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (!(trian == 3) && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1592,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 ^ a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1593,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= -1 || b <= -1 || c <= -1) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1594,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 ^ b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1595,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1596,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian * 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1597,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian > 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1598,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return 0;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1599,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a++ + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1600,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian++ == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1601,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian / 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1602,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a++ <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1603,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (true) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1604,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b * c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1605,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1606,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1607,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian-- == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1608,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1609,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = ~trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1610,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian-- + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1611,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < ~c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1612,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (false && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1613,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || ~a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1614,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == ~c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1615,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b <= c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1616,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (false && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1617,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b++) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1618,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian / 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1619,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || ++c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1620,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian <= 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1621,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (!(a + b < c || a + c < b) || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1622,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a++ == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1623,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a++) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1624,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1625,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c-- < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1626,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (!(a + b < c) || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1627,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 1 || b <= 1 || c <= 1) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1628,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian++ + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1629,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b != c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1630,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return ~EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1631,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && ++b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1632,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return ~INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1633,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > -3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1634,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (!(trian == 0)) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1635,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = --trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1636,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 ^ a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1637,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian < 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1638,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || --b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1639,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + --c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1640,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a-- + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1641,"public static  int classify( int a, int b, int c )
{
    int trian;
    if ((a <= 0 || b <= 0) ^ c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1642,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian - 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1643,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1644,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c++ < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1645,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a >= c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1646,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b == c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1647,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (--trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1648,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 || a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1649,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a++ + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1650,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (!(trian > 3)) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1651,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1652,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b++ < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1653,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 == a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1654,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian % 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1655,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (false) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1656,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b > 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1657,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b-- + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1658,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 0;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1659,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return 0;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1660,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1661,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1662,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = ++trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1663,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1664,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c++ <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1665,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return ~INVALID;
}"
1666,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1667,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 ^ b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1668,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b != 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1669,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian < 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1670,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (true) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1671,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || !(a + c < b) || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1672,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b--) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1673,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (~trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1674,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b == c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1675,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b--) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1676,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return -ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1677,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian > 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1678,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (false || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1679,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b != c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1680,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return 0;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1681,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || !(c <= 0)) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1682,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a-- + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1683,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == ++b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1684,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (!(trian == 2) && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1685,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
        }
    }
    return INVALID;
}"
1686,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ~ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1687,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return -INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1688,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian-- + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1689,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b != c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1690,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c++ < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1691,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a > 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1692,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == ~c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1693,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian >= 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1694,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b < c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1695,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 0;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1696,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + ++c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1697,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1698,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + --b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1699,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (~trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1700,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian++ == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1701,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c >= a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1702,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = --trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1703,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c >= a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1704,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian-- == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1705,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > ~a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1706,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1707,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + ++c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1708,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if ((a + b < c || a + c < b) && b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1709,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b-- == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1710,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c >= b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1711,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian % 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1712,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == -2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1713,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c--) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1714,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (--trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1715,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return ~INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1716,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c ^ a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1717,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = -trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1718,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || true) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1719,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && !(b + c > a)) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1720,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b > c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1721,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a >= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1722,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (true || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1723,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && !(a + b > c)) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1724,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c != a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1725,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1726,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (true && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1727,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (~trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1728,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && ~a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1729,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (!(a == b)) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1730,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b++ + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1731,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1732,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 0) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1733,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (++trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1734,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b-- <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1735,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b-- + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1736,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == ++c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1737,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + --c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1738,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + ~c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1739,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (true && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1740,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian++ == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1741,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1742,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && ++a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1743,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a-- + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1744,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (false) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1745,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (~a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1746,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a < c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1747,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && true) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1748,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1749,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 && b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1750,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = -trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1751,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b >= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1752,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == ++c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1753,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || --c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1754,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > ~b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1755,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c == b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1756,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a * b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1757,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b >= c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1758,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian == 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1759,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + -1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1760,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c-- > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1761,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 0;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1762,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a-- == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1763,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian++ + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1764,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if ((a + b < c || a + c < b) ^ b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1765,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian++ == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1766,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian < 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1767,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian != 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1768,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c == a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1769,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (!(a <= 0 || b <= 0) || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1770,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return -ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1771,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian-- > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1772,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian * 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1773,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1774,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian++ > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1775,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b-- < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1776,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c++) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1777,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian-- == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1778,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = -trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1779,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = ~trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1780,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c == b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1781,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return -INVALID;
}"
1782,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (~trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1783,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && --a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1784,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1785,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = -1;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1786,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (true) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1787,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || true || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1788,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a--) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1789,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (++trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1790,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && true) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1791,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || ~c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1792,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1793,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ~ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1794,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (true) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1795,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (++trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1796,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (--trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1797,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + -3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1798,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian != 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1799,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && ++a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1800,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b-- > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1801,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = ++trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1802,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + ++b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1803,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b++ == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1804,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return -SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1805,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || true) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1806,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c == a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1807,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c-- <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1808,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c <= b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1809,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c >= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1810,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || ++b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1811,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian++ + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1812,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 || a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1813,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c++) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1814,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian != 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1815,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + --b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1816,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c != 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1817,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian < 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1818,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a * b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1819,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ~ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1820,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a != b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1821,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 == a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1822,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + ++c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1823,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c >= b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1824,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c--) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1825,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && true) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1826,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || !(b + c < a)) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1827,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian > 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1828,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1829,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || false) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1830,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (++trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1831,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || !(b <= 0) || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1832,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b++ <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1833,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1834,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < ~a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1835,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (++b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1836,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (~a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1837,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || false) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1838,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + ~b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1839,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c < b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1840,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (!(a <= 0 || b <= 0 || c <= 0)) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1841,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return 0;
}"
1842,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c-- || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1843,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && ~b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1844,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == --c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1845,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b <= c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1846,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1847,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 || b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1848,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a++ == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1849,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return 0;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1850,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian-- == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1851,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (--trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1852,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (++a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1853,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || false || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1854,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return -INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1855,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c-- > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1856,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c++ || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1857,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a > b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1858,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c++ > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1859,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (true) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1860,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return 0;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1861,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (--a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1862,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c <= a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1863,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (true) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1864,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || ++a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1865,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian > 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1866,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1867,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c-- < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1868,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1869,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || --a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1870,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b++ || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1871,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || --b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1872,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == ~b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1873,"public static  int classify( int a, int b, int c )
{
    int trian;
    if (a <= 0 || b <= 0 || c <= 0) {
        return INVALID;
    }
    trian = 0;
    if (a == b) {
        trian = trian + 1;
    }
    if (a == c) {
        trian = ++trian + 2;
    }
    if (b == c) {
        trian = trian + 3;
    }
    if (trian == 0) {
        if (a + b < c || a + c < b || b + c < a) {
            return INVALID;
        } else {
            return SCALENE;
        }
    }
    if (trian > 3) {
        return EQUILATERAL;
    }
    if (trian == 1 && a + b > c) {
        return ISOSCELES;
    } else {
        if (trian == 2 && a + c > b) {
            return ISOSCELES;
        } else {
            if (trian == 3 && b + c > a) {
                return ISOSCELES;
            }
        }
    }
    return INVALID;
}"
1874,"public static void main(int b, int c, int d, int e, int f)
{	int i,j,xyz,y;int[]a=new int[5];
	a[0] = b;
	a[1] = c;
	a[2] = d;
	a[3] = e;
	a[4] = f;
	for(i=0;i<5;i++)
	{
		for(j=i+1;j<5;j++)
		{
			if(a[i]<a[j])
			{
				xyz=a[i];
				a[i]=a[j];
				a[j]=xyz;
		} }
		System.out.printf(""5d "",a[i]); }
}"
1875,"public static void main(int b, int c, int d, int e, int f)
{	int i,j,xyz,y;int[]a=new int[5];
	a[0] = b;
	a[1] = c;
	a[2] = d;
	a[3] = e;
	a[4] = f;
	for(i=0;i<5;i++)
	{
		for(j=i+1;j<5;j++)
		{
			if(a[i]<a[j])
			{
				xyz=a[i];
				a[i]=a[j];
				a[j]=xyz++;
		} }
		System.out.printf(""5d "",a[i]); }
}"
1876,"public static void main(int b, int c, int d, int e, int f)
{	int i,j,xyz,y;int[]a=new int[5];
	a[0] = b;
	a[1] = c;
	a[2] = d;
	a[3] = e;
	a[4] = f;
	for(i=0;i<5;i++)
	{
		for(j=i+1;j<5;j++)
		{
			if(a[i]<a[j])
			{
				xyz=a[i];
				a[i]=a[j]++;
				a[j]=xyz;
		} }
		System.out.printf(""5d "",a[i]); }
}"
1877,"public static void main(int b, int c, int d, int e, int f)
{	int i,j,xyz,y;int[]a=new int[5];
	a[0] = b;
	a[1] = c;
	a[2] = d;
	a[3] = e;
	a[4] = f;
	for(i=0;i<5;i++)
	{
		for(j=i+1;j<5;j++)
		{
			if(a[i]<a[j])
			{
				xyz=a[i];
				a[i]=a[j]--;
				a[j]=xyz;
		} }
		System.out.printf(""5d "",a[i]); }
}"
1878,"public static void main(int b, int c, int d, int e, int f)
{	int i,j,xyz,y;int[]a=new int[5];
	a[0] = b;
	a[1] = c;
	a[2] = d;
	a[3] = e;
	a[4] = f;
	for(i=0;i<5;i++)
	{
		for(j=i+1;j<5;j++)
		{
			if(a[i]<a[j])
			{
				xyz=a[i]++;
				a[i]=a[j];
				a[j]=xyz;
		} }
		System.out.printf(""5d "",a[i]); }
}"
1879,"public static void main(int b, int c, int d, int e, int f)
{	int i,j,xyz,y;int[]a=new int[5];
	a[0] = b;
	a[1] = c;
	a[2] = d;
	a[3] = e;
	a[4] = f;
	for(i=0;i<5;i++)
	{
		for(j=i+1;j<5;j++)
		{
			if(a[i]<a[j])
			{
				xyz=a[i];
				a[i]=a[j];
				a[j]=xyz--;
		} }
		System.out.printf(""5d "",a[i]); }
}"
1880,"public static void main(int b, int c, int d, int e, int f)
{	int i,j,xyz,y;int[]a=new int[5];
	a[0] = b;
	a[1] = c;
	a[2] = d;
	a[3] = e;
	a[4] = f;
	for(i=0;i<5;i++)
	{
		for(j=i+1;j<5;j++)
		{
			if(a[i]<a[j])
			{
				xyz=a[i]--;
				a[i]=a[j];
				a[j]=xyz;
		} }
		System.out.printf(""5d "",a[i]); }
}"
1881,"public static void main(int b, int c, int d, int e, int f)
{	int i,j,xyz,y;int[]a=new int[5];
	a[0] = b;
	a[1] = c;
	a[2] = d;
	a[3] = e;
	a[4] = f;
	for(i=0;i<5;i++)
	{
		for(j=i+1;j<5;j++)
		{
			if(a[i]<=a[j])
			{
				xyz=a[i];
				a[i]=a[j];
				a[j]=xyz;
		} }
		System.out.printf(""5d "",a[i]); }
}"
1882,"public static void main(int b, int c, int d, int e, int f)
{	int i,j,xyz,y;int[]a=new int[5];
	a[0] = b;
	a[1] = c;
	a[2] = d;
	a[3] = e;
	a[4] = f;
	for(i=0;i<5;i++)
	{
		for(j=i/1;j<5;j++)
		{
			if(a[i]<a[j])
			{
				xyz=a[i];
				a[i]=a[j];
				a[j]=xyz;
		} }
		System.out.printf(""5d "",a[i]); }
}"
1883,"public static void main(int b, int c, int d, int e, int f)
{	int i,j,xyz,y;int[]a=new int[5];
	a[0] = b;
	a[1] = c;
	a[2] = d;
	a[3] = e;
	a[4] = f;
	for(i=0;i<5;i++)
	{
		for(j=i*1;j<5;j++)
		{
			if(a[i]<a[j])
			{
				xyz=a[i];
				a[i]=a[j];
				a[j]=xyz;
		} }
		System.out.printf(""5d "",a[i]); }
}"
1884,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1885,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i++-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1886,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1887,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i%200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1888,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i++-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1889,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1890,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(abs(i)-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1891,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i---600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1892,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+++(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1893,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(abs(i)-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1894,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+++(i-1000000)*0.01;
return(bonus);
}"
1895,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i%100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1896,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+++(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1897,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i%600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1898,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6--+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1899,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+++(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1900,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i--*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1901,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1902,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i---100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1903,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10--+(i-1000000)*0.01;
return(bonus);
}"
1904,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i++-1000000)*0.01;
return(bonus);
}"
1905,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=abs(i)*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1906,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i---400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1907,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(abs(i)-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1908,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(abs(i)-1000000)*0.01;
return(bonus);
}"
1909,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1--+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1910,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1911,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i%400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1912,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i---1000000)*0.01;
return(bonus);
}"
1913,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i++-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1914,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i%1000000)*0.01;
return(bonus);
}"
1915,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
   return(bonus--);
}"
1916,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=abs(bonus10)+(i-1000000)*0.01;
return(bonus);
}"
1917,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i---200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1918,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=abs(bonus4)+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1919,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
   return(bonus++);
}"
1920,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=abs(bonus1)+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1921,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i++-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1922,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=abs(bonus2)+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1923,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i++*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1924,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+++(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1925,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1926,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(abs(i)-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1927,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
   return(abs(bonus));
}"
1928,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=abs(bonus6)+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1929,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2--+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1930,"double Profit(double i)
{
  double bonus1,bonus2,bonus4,bonus6,bonus10,bonus;
  bonus1=100000*0.1;
  bonus2=100000*0.1+100000*0.075;
  bonus4=100000*0.1+100000*0.075+200000*0.05;
  bonus6=100000*0.1+100000*0.075+200000*0.05+200000*0.03;
  bonus10=100000*0.1+100000*0.075+200000*0.05+200000*0.03+400000*0.015;
  if(i<=100000)
    bonus=i*0.1;
    else if(i<=200000)
      bonus=bonus1+(i-100000)*0.075;
        else if(i<=400000)
          bonus=bonus2+(i-200000)*0.05;
            else if(i<=600000)
              bonus=bonus4--+(i-400000)*0.03;
                else if(i<=1000000)
                  bonus=bonus6+(i-600000)*0.015;
                    else
                      bonus=bonus10+(i-1000000)*0.01;
return(bonus);
}"
1931,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1932,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs * (2 * slot);
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1933,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs / (2 * slot);
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1934,"public boolean removeNode(int nodeId)
		throws pamvotis.exceptions.ElementDoesNotExistException {
	int position = -1;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == nodeId) {
			position = i;
			break;
		}
	}
	if (position != -1) {
		nodesList.removeElementAt(position);
		nmbrOfNodes--;
		return true;
	} else {
		throw new pamvotis.exceptions.ElementDoesNotExistException(""Node ""
				+ nodeId + "" does not exist."");
	}
}"
1935,"public boolean removeNode(int nodeId)
		throws pamvotis.exceptions.ElementDoesNotExistException {
	int position = -1;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == nodeId) {
			position = i;
			break;
		}
	}
	if (position != 0) {
		nodesList.removeElementAt(position);
		nmbrOfNodes--;
		return true;
	} else {
		throw new pamvotis.exceptions.ElementDoesNotExistException(""Node ""
				+ nodeId + "" does not exist."");
	}
}"
1936,"public boolean removeNode(int nodeId)
		throws pamvotis.exceptions.ElementDoesNotExistException {
	int position = -1;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == nodeId) {
			position = i;
			break;
		}
	}
	if (position < -1) {
		nodesList.removeElementAt(position);
		nmbrOfNodes--;
		return true;
	} else {
		throw new pamvotis.exceptions.ElementDoesNotExistException(""Node ""
				+ nodeId + "" does not exist."");
	}
}"
1937,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs % (2 * slot);
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1938,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 + slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1939,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 / slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1940,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 - slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1941,"public boolean removeNode(int nodeId)
		throws pamvotis.exceptions.ElementDoesNotExistException {
	int position = 0;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == nodeId) {
			position = i;
			break;
		}
	}
	if (position != -1) {
		nodesList.removeElementAt(position);
		nmbrOfNodes--;
		return true;
	} else {
		throw new pamvotis.exceptions.ElementDoesNotExistException(""Node ""
				+ nodeId + "" does not exist."");
	}
}"
1942,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs % (aifs1 * slot);
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1943,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs - aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1944,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs / (aifs1 * slot);
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1945,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (true) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1946,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 - slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1947,"public boolean removeNode(int nodeId)
		throws pamvotis.exceptions.ElementDoesNotExistException {
	int position = 1;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == nodeId) {
			position = i;
			break;
		}
	}
	if (position != -1) {
		nodesList.removeElementAt(position);
		nmbrOfNodes--;
		return true;
	} else {
		throw new pamvotis.exceptions.ElementDoesNotExistException(""Node ""
				+ nodeId + "" does not exist."");
	}
}"
1948,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = true;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1949,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 + slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1950,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 1; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1951,"public boolean removeNode(int nodeId)
		throws pamvotis.exceptions.ElementDoesNotExistException {
	int position = -1;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == nodeId) {
			position = i;
			break;
		}
	}
	if (true) {
		nodesList.removeElementAt(position);
		nmbrOfNodes--;
		return true;
	} else {
		throw new pamvotis.exceptions.ElementDoesNotExistException(""Node ""
				+ nodeId + "" does not exist."");
	}
}"
1952,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 / slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1953,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs - 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1954,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 + slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1955,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 / slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1956,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 / slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1957,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 % slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1958,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 - slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1959,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = -1; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1960,"public boolean removeNode(int nodeId)
		throws pamvotis.exceptions.ElementDoesNotExistException {
	int position = -1;
	for (int i = 0; false; i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == nodeId) {
			position = i;
			break;
		}
	}
	if (position != -1) {
		nodesList.removeElementAt(position);
		nmbrOfNodes--;
		return true;
	} else {
		throw new pamvotis.exceptions.ElementDoesNotExistException(""Node ""
				+ nodeId + "" does not exist."");
	}
}"
1961,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs / (aifs0 * slot);
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1962,"public boolean removeNode(int nodeId)
		throws pamvotis.exceptions.ElementDoesNotExistException {
	int position = -1;
	for (int i = 1; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == nodeId) {
			position = i;
			break;
		}
	}
	if (position != -1) {
		nodesList.removeElementAt(position);
		nmbrOfNodes--;
		return true;
	} else {
		throw new pamvotis.exceptions.ElementDoesNotExistException(""Node ""
				+ nodeId + "" does not exist."");
	}
}"
1963,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs - aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1964,"public boolean removeNode(int nodeId)
		throws pamvotis.exceptions.ElementDoesNotExistException {
	int position = -1;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == nodeId) {
			position = i;
			break;
		}
	}
	if (position != 1) {
		nodesList.removeElementAt(position);
		nmbrOfNodes--;
		return true;
	} else {
		throw new pamvotis.exceptions.ElementDoesNotExistException(""Node ""
				+ nodeId + "" does not exist."");
	}
}"
1965,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 % slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1966,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 + slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1967,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs * (aifs2 * slot);
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1968,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs * (aifs1 * slot);
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1969,"public boolean removeNode(int nodeId)
		throws pamvotis.exceptions.ElementDoesNotExistException {
	int position = -1;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == nodeId) {
			position = i;
			break;
		}
	}
	if (position != -1) {
		nodesList.removeElementAt(position);
		;
		return true;
	} else {
		throw new pamvotis.exceptions.ElementDoesNotExistException(""Node ""
				+ nodeId + "" does not exist."");
	}
}"
1970,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 - slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1971,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs - aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1972,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 + slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1973,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs * (aifs3 * slot);
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1974,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 % slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1975,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs % (aifs0 * slot);
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1976,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 - slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1977,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs / (aifs2 * slot);
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1978,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs % (aifs2 * slot);
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1979,"public boolean removeNode(int nodeId)
		throws pamvotis.exceptions.ElementDoesNotExistException {
	int position = -1;
	for (int i = 0; i != nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == nodeId) {
			position = i;
			break;
		}
	}
	if (position != -1) {
		nodesList.removeElementAt(position);
		nmbrOfNodes--;
		return true;
	} else {
		throw new pamvotis.exceptions.ElementDoesNotExistException(""Node ""
				+ nodeId + "" does not exist."");
	}
}"
1980,"public boolean removeNode(int nodeId)
		throws pamvotis.exceptions.ElementDoesNotExistException {
	int position = -1;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == nodeId) {
			position = i;
			break;
		}
	}
	if (position > -1) {
		nodesList.removeElementAt(position);
		nmbrOfNodes--;
		return true;
	} else {
		throw new pamvotis.exceptions.ElementDoesNotExistException(""Node ""
				+ nodeId + "" does not exist."");
	}
}"
1981,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; false; i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1982,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs / (aifs3 * slot);
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1983,"public boolean removeNode(int nodeId)
		throws pamvotis.exceptions.ElementDoesNotExistException {
	int position = -1;
	for (int i = 0; i <= nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == nodeId) {
			position = i;
			break;
		}
	}
	if (position != -1) {
		nodesList.removeElementAt(position);
		nmbrOfNodes--;
		return true;
	} else {
		throw new pamvotis.exceptions.ElementDoesNotExistException(""Node ""
				+ nodeId + "" does not exist."");
	}
}"
1984,"public boolean removeNode(int nodeId)
		throws pamvotis.exceptions.ElementDoesNotExistException {
	int position = -1;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == nodeId) {
			position = i;
			break;
		}
	}
	if (position != -1) {
		;
		nmbrOfNodes--;
		return true;
	} else {
		throw new pamvotis.exceptions.ElementDoesNotExistException(""Node ""
				+ nodeId + "" does not exist."");
	}
}"
1985,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 % slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1986,"public boolean removeNode(int nodeId)
		throws pamvotis.exceptions.ElementDoesNotExistException {
	int position = -1;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == nodeId) {
			position = i;
			break;
		}
	}
	if (position != -1) {
		nodesList.removeElementAt(position);
		nmbrOfNodes--;
		return false;
	} else {
		throw new pamvotis.exceptions.ElementDoesNotExistException(""Node ""
				+ nodeId + "" does not exist."");
	}
}"
1987,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 % slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1988,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i <= nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1989,"public boolean removeNode(int nodeId)
		throws pamvotis.exceptions.ElementDoesNotExistException {
	int position = -1;
	for (int i = -1; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == nodeId) {
			position = i;
			break;
		}
	}
	if (position != -1) {
		nodesList.removeElementAt(position);
		nmbrOfNodes--;
		return true;
	} else {
		throw new pamvotis.exceptions.ElementDoesNotExistException(""Node ""
				+ nodeId + "" does not exist."");
	}
}"
1990,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		;
		nmbrOfNodes++;
	}
}"
1991,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (false) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1992,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 0 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1993,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs % (aifs3 * slot);
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1994,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 / slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1995,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs - aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1996,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = false;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1997,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		;
	}
}"
1998,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + -2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
1999,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i != nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs + aifs0 * slot;
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
2000,"public void addNode(int id, int rate, int coverage, int xPosition,
		int yPosition, int ac)
		throws pamvotis.exceptions.ElementExistsException {
	boolean nodeExists = false;
	for (int i = 0; i < nodesList.size(); i++) {
		if (((pamvotis.core.MobileNode) nodesList.elementAt(i)).params.id == id) {
			nodeExists = true;
			break;
		}
	}
	if (nodeExists) {
		throw new pamvotis.exceptions.ElementExistsException(""Node "" + id
				+ "" already exists."");
	} else {
		pamvotis.core.MobileNode nd = new pamvotis.core.MobileNode();
		int nCwMin = cwMin;
		int nCwMax = SpecParams.CW_MAX;
		float nAifsd = sifs + 2 * slot;
		switch (ac) {
		case 1: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact1);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact1);
			nAifsd = sifs + aifs1 * slot;
			break;
		}

		case 2: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact2);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact2);
			nAifsd = sifs + aifs2 * slot;
			break;
		}

		case 3: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact3);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact3);
			nAifsd = sifs + aifs3 * slot;
			break;
		}

		default: {
			nCwMin = (int) ((float) cwMin / (float) cwMinFact0);
			nCwMax = (int) ((float) SpecParams.CW_MAX / (float) cwMaxFact0);
			nAifsd = sifs * (aifs0 * slot);
			break;
		}

		}
		nd.params.InitParams(id, rate, xPosition, yPosition, coverage, ac,
				nAifsd, nCwMin, nCwMax);
		nd.contWind = nd.params.cwMin;
		nodesList.addElement(nd);
		nmbrOfNodes++;
	}
}"
2001,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2002,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 1);
    return -u * (1 << k); // gcd is u*2^k
}"
2003,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) - 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2004,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (false) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2005,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t > 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2006,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) % Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2007,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= -2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2008,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while (false && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2009,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & -1) == 0 && (v & -1) == 0 && k < 3-1) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2010,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2011,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > -1) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2012,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u + 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2013,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) <= 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2014,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 1) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2015,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : +(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2016,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 == ((v & 1) == 0) && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2017,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = (false) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2018,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 0) == 0 && (v & 0) == 0 && k < 30) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2019,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 1;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2020,"public static int gcd(int u, int v) {
    if (false) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2021,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (false) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2022,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) >= 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2023,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && false && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2024,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > -1) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2025,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        ; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2026,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v % u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2027,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = +u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2028,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u % 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2029,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 1) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2030,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < -31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2031,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 0; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2032,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while (((u & 1) == 0 && (v & 1) == 0) == k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2033,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while (false) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2034,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 0;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2035,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u + (1 << k); // gcd is u*2^k
}"
2036,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == -31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2037,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) <= 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2038,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 1) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2039,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        ;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2040,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return ~u * (1 << k); // gcd is u*2^k
}"
2041,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t >= 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2042,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 0;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2043,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (0 << k); // gcd is u*2^k
}"
2044,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) * 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2045,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k >= 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2046,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k != 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2047,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (false) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2048,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while (false) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2049,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : ~(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2050,"public static int gcd(int u, int v) {
    if (u + v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2051,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return +u * (1 << k); // gcd is u*2^k
}"
2052,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 0) == 0) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2053,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t ^ 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2054,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / -2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2055,"public static int gcd(int u, int v) {
    if (u * v >= 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2056,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            ; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2057,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = +v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2058,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 0) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2059,"public static int gcd(int u, int v) {
    if (u * v == -1) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2060,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) >= 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2061,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && false) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2062,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u ^ 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2063,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v + u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2064,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= -2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2065,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = ~u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2066,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v >= 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2067,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != -1);
    return -u * (1 << k); // gcd is u*2^k
}"
2068,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 0)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2069,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u ^ 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2070,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u / (1 << k); // gcd is u*2^k
}"
2071,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u | 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2072,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = -1;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2073,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v / u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2074,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & -1) == -1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2075,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k <= 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2076,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u >= 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2077,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > -1) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2078,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 1 && (v & 1) == 1 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2079,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v * u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2080,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (false) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2081,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == -1) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2082,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u % (1 << k); // gcd is u*2^k
}"
2083,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v | 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2084,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 0) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2085,"public static int gcd(int u, int v) {
    if (u % v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2086,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & -1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2087,"public static int gcd(int u, int v) {
    if (u - v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2088,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u - 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2089,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t < 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2090,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) * Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2091,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) - Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2092,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) + 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2093,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t | 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2094,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v ^ 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2095,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2096,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k <= 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2097,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u != 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2098,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (true);
    return -u * (1 << k); // gcd is u*2^k
}"
2099,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 1) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2100,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 >> k); // gcd is u*2^k
}"
2101,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u * 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2102,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = ~v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2103,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 0) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2104,"public static int gcd(int u, int v) {
    if (u * v <= 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2105,"public static int gcd(int u, int v) {
    if (u / v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2106,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) <= 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2107,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while (false && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2108,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == -1 && (v & 1) == -1 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2109,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (-1 << k); // gcd is u*2^k
}"
2110,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = +t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2111,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / -2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2112,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = ~t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2113,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) / Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2114,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 >>> k); // gcd is u*2^k
}"
2115,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v != 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2116,"public static int gcd(int u, int v) {
    if (u * v == 1) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2117,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 0;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2118,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= -2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2119,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2120,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) <= 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2121,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        ;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2122,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u | 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2123,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while (k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2124,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t != 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2125,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) >= 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2126,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) % 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2127,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) == 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u - (1 << k); // gcd is u*2^k
}"
2128,"public static int gcd(int u, int v) {
    if (u * v == 0) {
        return (Math.abs(u) + Math.abs(v));
    }
    // keep u and v negative, as negative integers range down to
    // -2^31, while positive numbers can only be as large as 2^31-1
    // (i.e. we can't necessarily negate a negative number without
    // overflow)
    /* assert u!=0 && v!=0; */
    if (u > 0) {
        u = -u;
    } // make u negative
    if (v > 0) {
        v = -v;
    } // make v negative
    // B1. [Find power of 2]
    int k = 0;
    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                        // both even...
        u /= 2;
        v /= 2;
        k++; // cast out twos.
    }
    if (k == 31) {
        throw new ArithmeticException(""overflow: gcd is 2^31"");
    }
    // B2. Initialize: u and v have been divided by 2^k and at least
    // one is odd.
    int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
    // t negative: u was odd, v may be even (t replaces v)
    // t positive: u was even, v is odd (t replaces u)
    do {
        /* assert u<0 && v<0; */
        // B4/B3: cast out twos from t.
        while ((t & 1) >= 0) { // while t is even..
            t /= 2; // cast out twos
        }
        // B5 [reset max(u,v)]
        if (t > 0) {
            u = -t;
        } else {
            v = t;
        }
        // B6/B3. at this point both u and v should be odd.
        t = (v - u) / 2;
        // |u| larger: t positive (replace u)
        // |v| larger: t negative (replace v)
    } while (t != 0);
    return -u * (1 << k); // gcd is u*2^k
}"
2129,"public static void main(String args[])
{
int m,i,k,h=0,leap=1;
System.out.print(""\n"");
for(m=1;m<=5;m++)
{
	k=(int)Math.sqrt(m+1);
	for(i=2;i<=k;i++)
	{
		if(m%i==0)
		{
			leap=0;
			break;
		}
	}
	if(leap!=0)
	{
		System.out.printf(""%-4d"",m);
		h++;
		if(h%10==0)
			System.out.printf(""\n"");
	}
	leap=1;
}
System.out.printf(""\nThe total is %d"",h);
}"
2130,"public static void main(String args[])
{
int m,i,k,h=0,leap=1;
System.out.print(""\n"");
for(m=1;m<=5;m++)
{
	k=(int)Math.sqrt(m*1);
	for(i=2;i<=k;i++)
	{
		if(m%i==0)
		{
			leap=0;
			break;
		}
	}
	if(leap!=0)
	{
		System.out.printf(""%-4d"",m);
		h++;
		if(h%10==0)
			System.out.printf(""\n"");
	}
	leap=1;
}
System.out.printf(""\nThe total is %d"",h);
}"
2131,"public static void main(String args[])
{
int m,i,k,h=0,leap=1;
System.out.print(""\n"");
for(m=1;m<=5;m++)
{
	k=(int)Math.sqrt(m+1);
	for(i=2;i<=k;i++)
	{
		if(m%i==0)
		{
			leap=0;
			break;
		}
	}
	if(leap!=0)
	{
		System.out.printf(""%-4d"",m);
		h++;
		if(h%10==0)
			System.out.printf(""\n"");
	}
	leap=1;
}
System.out.printf(""\nThe total is %d"",Math.abs(h));
}"
2132,"public static void main(String args[])
{
int m,i,k,h=0,leap=1;
System.out.print(""\n"");
for(m=1;m<=5;m++)
{
	k=(int)Math.sqrt(m/1);
	for(i=2;i<=k;i++)
	{
		if(m%i==0)
		{
			leap=0;
			break;
		}
	}
	if(leap!=0)
	{
		System.out.printf(""%-4d"",m);
		h++;
		if(h%10==0)
			System.out.printf(""\n"");
	}
	leap=1;
}
System.out.printf(""\nThe total is %d"",h);
}"
2133,"public static void main(String args[])
{
int m,i,k,h=0,leap=1;
System.out.print(""\n"");
for(m=1;m<=5;m++)
{
	k=(int)Math.sqrt(m+1);
	for(i=2;i<=k;i++)
	{
		if(m%i==0)
		{
			leap=0;
			break;
		}
	}
	if(leap!=0)
	{
		System.out.printf(""%-4d"",m);
		h++;
		if(h%10==0)
			System.out.printf(""\n"");
	}
	leap=1;
}
System.out.printf(""\nThe total is %d"",h++);
}"
2134,"public static void main(String args[])
{
int m,i,k,h=0,leap=1;
System.out.print(""\n"");
for(m=1;m<=5;m++)
{
	k=(int)Math.sqrt(m+1);
	for(i=2;i<=k;i++)
	{
		if(m%i==0)
		{
			leap=0;
			break;
		}
	}
	if(leap!=0)
	{
		System.out.printf(""%-4d"",Math.abs(m));
		h++;
		if(h%10==0)
			System.out.printf(""\n"");
	}
	leap=1;
}
System.out.printf(""\nThe total is %d"",h);
}"
2135,"public static void main(String args[])
{
int m,i,k,h=0,leap=1;
System.out.print(""\n"");
for(m=1;m<=5;m++)
{
	k=(int)Math.sqrt(m+1);
	for(i=2;i<=k;i++)
	{
		if(m%i==0)
		{
			leap=0;
			break;
		}
	}
	if(leap!=0)
	{
		System.out.printf(""%-4d"",m);
		h++;
		if(h%10==0)
			System.out.printf(""\n"");
	}
	leap=1;
}
System.out.printf(""\nThe total is %d"",h--);
}"
2136,"public static void main(String args[])
{
int m,i,k,h=0,leap=1;
System.out.print(""\n"");
for(m=1;m<=5;m++)
{
	k=(int)Math.sqrt(Math.abs(m)+1);
	for(i=2;i<=k;i++)
	{
		if(m%i==0)
		{
			leap=0;
			break;
		}
	}
	if(leap!=0)
	{
		System.out.printf(""%-4d"",m);
		h++;
		if(h%10==0)
			System.out.printf(""\n"");
	}
	leap=1;
}
System.out.printf(""\nThe total is %d"",h);
}"
2137,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2138,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length % 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2139,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2140,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (false) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2141,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2142,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (false) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2143,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2144,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive >= array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2145,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2146,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 0;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2147,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (true) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2148,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2149,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    ;
    return subarray;
}"
2150,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2151,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length % 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2152,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= 0) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2153,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive / startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= 0) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2154,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2155,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 1) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2156,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (false) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= 0) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2157,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, -1, newSize);
    return subarray;
}"
2158,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2159,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (false) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2160,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2161,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 1;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2162,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2163,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind >= array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2164,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; true; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2165,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length / 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2166,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length * 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2167,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive <= 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2168,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2169,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - -1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2170,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < -1) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2171,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (true) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2172,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize == 0) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2173,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= -1) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2174,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; true; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2175,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex > array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2176,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 1; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2177,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= 0) {
        return (Object[]) Array.newInstance(type, -1);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2178,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize == 0) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2179,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2180,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize < 0) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2181,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i == 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2182,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= -1) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2183,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i == 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2184,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (false) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2185,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (false) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2186,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive != 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2187,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (false) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2188,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    ;
    return subarray;
}"
2189,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2190,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive <= 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2191,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive / startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2192,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex != 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2193,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2194,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind >= array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2195,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (true) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2196,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2197,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < -1) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2198,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - -1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2199,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i > 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2200,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex == array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2201,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 1, newSize);
    return subarray;
}"
2202,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length * 1.5));
    for (int i = 0; i < array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length < 2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[0], entry[1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2203,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length / 1.5));
    for (int i = 0; i < array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length < 2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[0], entry[1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2204,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (false) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2205,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind / tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2206,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] > min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2207,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive != array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2208,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, -1, newSize);
    return subarray;
}"
2209,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex <= 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2210,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 0;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2211,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind <= array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2212,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2213,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, -1, newSize);
    return subarray;
}"
2214,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (false) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2215,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 1; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2216,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize < 0) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2217,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 1; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2218,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive * startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= 0) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2219,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2220,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind >= array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2221,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind - tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2222,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length * 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2223,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 1) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2224,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length * 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2225,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 0;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2226,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex != 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2227,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (false) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2228,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive + startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2229,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (true) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2230,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 1; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2231,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; true; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2232,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2233,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = -1;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2234,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (true) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2235,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive != array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= 0) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2236,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = -1;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2237,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (false) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2238,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (true) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2239,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (false) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2240,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length % 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2241,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 1) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2242,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; true; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2243,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive * startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2244,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i == 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2245,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length * 1.5));
    for (int i = 0; i < array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length < -2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[0], entry[1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2246,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; true; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2247,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive / startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2248,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex == array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2249,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length % 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2250,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length * 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2251,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive + startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2252,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length * 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2253,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex != 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2254,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - -1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2255,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 1;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2256,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex == array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2257,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive % startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2258,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive * startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2259,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= -1) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2260,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length * 1.5));
    for (int i = 0; false; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length < 2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[0], entry[1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2261,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min == array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2262,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex != 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2263,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length * 1.5));
    for (int i = -1; i < array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length < 2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[0], entry[1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2264,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 1) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2265,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive != array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2266,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (true) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2267,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < -1) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2268,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 1;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= 0) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2269,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 1) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2270,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 1) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2271,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (true) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2272,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= -1) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2273,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < -1) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2274,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i > 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2275,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive >= array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2276,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex == array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2277,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= -1; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2278,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length % 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2279,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    ;
    return subarray;
}"
2280,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 1) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2281,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (false) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2282,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (false) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2283,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length * 0.0));
    for (int i = 0; i < array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length < 2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[0], entry[1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2284,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length / 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2285,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 1, newSize);
    return subarray;
}"
2286,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 1; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2287,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length / 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2288,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < -1) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2289,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex != 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2290,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - -1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2291,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (true) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2292,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive != 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2293,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, -1, newSize);
    return subarray;
}"
2294,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (false) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2295,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= -1; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2296,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (false) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2297,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 1) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2298,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length * 1.5));
    for (int i = 0; i < array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length <= 2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[0], entry[1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2299,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex != 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2300,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && true) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2301,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive + startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2302,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (false) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2303,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= -1; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2304,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i == 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2305,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive >= array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2306,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive % startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2307,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive % startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= 0) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2308,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 1, newSize);
    return subarray;
}"
2309,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= -1; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2310,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - -1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2311,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (false) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2312,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= -1; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2313,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive != array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2314,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] == min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2315,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2316,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (false) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2317,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length * 1.5));
    for (int i = 0; i < array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length < 2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[0], entry[-1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2318,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 1; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2319,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (false) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2320,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive * startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2321,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (true) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2322,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 1) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2323,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length * -1.5));
    for (int i = 0; i < array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length < 2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[0], entry[1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2324,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize == 0) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2325,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length / 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2326,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < -1) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2327,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex > array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2328,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i == 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2329,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive * startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2330,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex == array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2331,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; true; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2332,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length + 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2333,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, -1, newSize);
    return subarray;
}"
2334,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive >= array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2335,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    ;
    return subarray;
}"
2336,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length + 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2337,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (false) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2338,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize == 0) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2339,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex <= 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2340,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind <= array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2341,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex == array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2342,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive != 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2343,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < -1) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2344,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex > array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2345,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (false) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2346,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (false) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2347,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 1) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2348,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (true) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2349,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= -1) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2350,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (false) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2351,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 0;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2352,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, -1, newSize);
    return subarray;
}"
2353,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (false) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2354,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = -1;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= 0) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2355,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (false) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2356,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 1) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2357,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (false) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2358,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < -1) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2359,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex != 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2360,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; true; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2361,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 1; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2362,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (false) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2363,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive <= 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2364,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length + 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2365,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize < 0) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2366,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= 0) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    ;
    return subarray;
}"
2367,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (false) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2368,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= -1; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2369,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= -1; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2370,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length % 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2371,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length * 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2372,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= 0) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, -1, newSize);
    return subarray;
}"
2373,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind <= array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2374,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (false) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2375,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex <= 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2376,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex == array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2377,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length + 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2378,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < -1) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2379,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive != 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2380,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i > 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2381,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive * startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2382,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] < max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2383,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, -1, newSize);
    return subarray;
}"
2384,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length * 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2385,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i == 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2386,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= 0) {
        return (Object[]) Array.newInstance(type, 1);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2387,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 1) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= 0) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2388,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= -1; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2389,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 1;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2390,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (false) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2391,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 1) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2392,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind % tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2393,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i > 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2394,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - -1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2395,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex > array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2396,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 0;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2397,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex > array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2398,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 1; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2399,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    ;
    return subarray;
}"
2400,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 1) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2401,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 1; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2402,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (false) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2403,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive != 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= 0) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2404,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (false) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= 0) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2405,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex != 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2406,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 1) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2407,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (false) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2408,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (false) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2409,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (false) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2410,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length % 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2411,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length * 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2412,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex > array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2413,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    ;
    return subarray;
}"
2414,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = -1;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2415,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < -1) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2416,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize < 0) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2417,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < -1) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2418,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex <= 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2419,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive + startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2420,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind >= array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2421,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive / startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2422,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 1;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2423,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length * 1.5));
    for (int i = 0; i < array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            ;
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length < 2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[0], entry[1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2424,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive / startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2425,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length * 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2426,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length * 1.5));
    for (int i = 0; i < array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length < 2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[0], entry[0]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2427,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive % startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2428,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex <= 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2429,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex <= 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2430,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; true; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2431,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex > array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2432,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= -1) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2433,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = -1;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2434,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (false) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2435,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (false) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2436,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] == max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2437,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (true) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2438,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    ;
    return subarray;
}"
2439,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < -1) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2440,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i > 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2441,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < -1) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2442,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= -1) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2443,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize == 0) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2444,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (false) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2445,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive % startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2446,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex == array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2447,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive <= 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2448,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex == array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2449,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (false) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2450,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (false) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2451,"public static Map toMap(Object[] array) {
    if (false) {
        return null;
    }
    final Map map = new HashMap((int) (array.length * 1.5));
    for (int i = 0; i < array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length < 2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[0], entry[1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2452,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < -1) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2453,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive != 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2454,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length / 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2455,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 1) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2456,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length + 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2457,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive != 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2458,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize < 0) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2459,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length / 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2460,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex != 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2461,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind <= array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2462,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex <= 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2463,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive >= array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2464,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (false) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= 0) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2465,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive + startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2466,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < -1) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2467,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive != array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2468,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (false) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2469,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length * 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2470,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive != array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2471,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length / 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2472,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind + tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2473,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive >= array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2474,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind >= array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2475,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 1) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2476,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 1;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2477,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < -1) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= 0) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2478,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2479,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive <= 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2480,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length + 1.5));
    for (int i = 0; i < array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length < 2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[0], entry[1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2481,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind >= array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2482,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length * 1.5));
    for (int i = 0; i < array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length < 2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            ;
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2483,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind * tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2484,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (true) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2485,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 0;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2486,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize < 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2487,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind <= array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2488,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (false) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2489,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 1) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2490,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i == 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2491,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length + 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2492,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex == array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2493,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (true) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2494,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive != array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2495,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i > 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2496,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize < 0) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2497,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 1, newSize);
    return subarray;
}"
2498,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i == 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2499,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= -1; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2500,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 1) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2501,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex <= 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2502,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex > array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2503,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (true && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2504,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= -1) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2505,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    ;
    return subarray;
}"
2506,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2507,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (false) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2508,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i > 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2509,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive <= 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2510,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive % startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2511,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive + startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= 0) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2512,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= -1; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2513,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length * 1.5));
    for (int i = 1; i < array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length < 2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[0], entry[1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2514,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive % startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2515,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize == 0) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2516,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (false) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2517,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive * startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2518,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (false) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2519,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 1) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2520,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (false) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2521,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; true; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2522,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 1, newSize);
    return subarray;
}"
2523,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive >= array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= 0) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2524,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive != array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2525,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (false) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2526,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length * 1.5));
    for (int i = 0; i < array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length < 2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[1], entry[1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2527,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (true) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2528,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (true) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2529,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive <= 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2530,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length / 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2531,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (true) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2532,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < -1) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2533,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - -1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2534,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length * 1.5));
    for (int i = 0; i <= array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length < 2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[0], entry[1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2535,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 0;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2536,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length + 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2537,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i > 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2538,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length + 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2539,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 1) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2540,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex > array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2541,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (true) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2542,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, -1, newSize);
    return subarray;
}"
2543,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive % startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2544,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive / startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2545,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive <= 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2546,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = -1;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2547,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = -1;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2548,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (true) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2549,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize == 0) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2550,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < -1) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2551,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (false) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2552,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 0;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2553,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i > 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2554,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive <= 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= 0) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2555,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive / startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2556,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 1;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2557,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length - 1.5));
    for (int i = 0; i < array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length < 2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[0], entry[1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2558,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length * 1.5));
    for (int i = 0; i < array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length != 2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[0], entry[1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2559,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length + 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2560,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= -1) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2561,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 1, newSize);
    return subarray;
}"
2562,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (false) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2563,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind <= array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2564,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive * startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2565,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind >= array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2566,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive != array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2567,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (false) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2568,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i == 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2569,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex > array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2570,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind * tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2571,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive != 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2572,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind <= array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2573,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; true; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2574,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize < 0) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2575,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (true) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2576,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex != 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2577,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive + startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2578,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length % 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2579,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length % 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2580,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive + startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2581,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 1;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2582,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize == 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2583,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length % 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2584,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - -1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2585,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (false) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2586,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex <= 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2587,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length % 1.5));
    for (int i = 0; i < array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length < 2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[0], entry[1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2588,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length * 1.5));
    for (int i = 0; i < array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (false) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[0], entry[1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2589,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length / 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2590,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i == 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2591,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 0;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2592,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 1;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2593,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive != 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2594,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (false) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2595,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (false) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2596,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind % tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2597,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 1) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2598,"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 1; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2599,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - -1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2600,"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 1) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }

    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2601,"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 0;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2602,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (false) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2603,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length * 1.5));
    for (int i = 0; i != array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length < 2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[0], entry[1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2604,"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = -1;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }

    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2605,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex <= 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2606,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 1, newSize);
    return subarray;
}"
2607,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= -1; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2608,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (true) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2609,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize == 0) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2610,"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < -1) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2611,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length * 1.5));
    for (int i = 0; i < array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length < 2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[-1], entry[1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2612,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive + startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2613,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 1) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2614,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (false) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2615,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive >= array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2616,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length + 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2617,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive % startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2618,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 1; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2619,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 1) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2620,"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize < 0) {
        return EMPTY_FLOAT_ARRAY;
    }

    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2621,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive >= array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2622,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; true; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2623,"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i > 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2624,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive / startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2625,"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 1) {
        return EMPTY_BYTE_ARRAY;
    }

    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2626,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive / startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2627,"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }

    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 1, newSize);
    return subarray;
}"
2628,"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length / 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2629,"public static Map toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map map = new HashMap((int) (array.length * 1.5));
    for (int i = 0; i < array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry) {
            Map.Entry entry = (Map.Entry) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length < 0) {
                throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', has a length less than 2"");
            }
            map.put(entry[0], entry[1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '""
                    + object
                    + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}"
2630,"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 1) {
        return EMPTY_BOOLEAN_ARRAY;
    }

    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2631,"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = -1;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }

    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2632,"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive * startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }

    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2633,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (false) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2634,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i > 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2635,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (true) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2636,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= 1) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}"
2637,"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - -1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2638,"public static Object[] subarray(Object[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class type = array.getClass().getComponentType();
    if (newSize <= 0) {
        return (Object[]) Array.newInstance(type, 0);
    }
    Object[] subarray = (Object[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 1, newSize);
    return subarray;
}"
2639,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (true) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2640,"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (false) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2641,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind / tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2642,"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (true) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}"
2643,"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i == 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}"
2644,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1;
	else
		leap=0;
	if(leap==1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}"
2645,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1;
	else
		leap=0;
	if(leap--==1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}"
2646,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1;
	else
		leap=0;
	if(leap==1&&month++>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}"
2647,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day;
	if(year%400==0||(year%4<=0&&year%100!=0))
		leap=1;
	else
		leap=0;
	if(leap==1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}"
2648,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1;
	else
		leap=0;
	if(leap>=1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}"
2649,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day--;
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1;
	else
		leap=0;
	if(leap==1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}"
2650,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day;
	if(year%400==0||(year%4==0&&year--%100!=0))
		leap=1;
	else
		leap=0;
	if(leap==1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}"
2651,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day;
	if(year%400==0||(year%4==0&&year++%100!=0))
		leap=1;
	else
		leap=0;
	if(leap==1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}"
2652,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1;
	else
		leap=0;
	if(leap==1&&month-->2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}"
2653,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1;
	else
		leap=0;
	if(leap++==1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}"
2654,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day++;
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1;
	else
		leap=0;
	if(leap==1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}"
2655,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day;
	if(year%400==0||(year%4==0&&year%100>0))
		leap=1;
	else
		leap=0;
	if(leap==1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}"
2656,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+abs(day);
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1;
	else
		leap=0;
	if(leap==1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}"
2657,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=abs(sum)+day;
	if(year%400==0||(year%4==0&&year%100!=0))
		leap=1;
	else
		leap=0;
	if(leap==1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}"
2658,"public static void main(int day, int month, int year)
{
	 int sum=0,leap;
	System.out.printf(""\n please input year,month,day\n"");
	switch(month)
	{	case 1:sum=0;
			break;
		case 2:sum=31;
			break;
		case 3:sum=59;
			break;
		case 4:sum=90;
			break;
		case 5:sum=120;
			break;
		case 6:sum=151;
			break;
		case 7:sum=181;
			break;
		case 8:sum=212;
			break;
		case 9:sum=243;
			break;
		case 10:sum=273;
			break;
		case 11:sum=304;
			break;
		case 12:sum=334;
			break;
		default:System.out.printf(""data error"");
			break; }
	sum=sum+day;
	if(year%400<=0||(year%4==0&&year%100!=0))
		leap=1;
	else
		leap=0;
	if(leap==1&&month>2)
		sum++;
	System.out.printf(""It is the %d th day."",sum);
}"
2659,"public static int min(int I, int J)
{
	int Min;
    Min = I;
    if(J<I) {
 	   Min=J;}
    return Min;
}"
2660,"public static int min(int I, int J)
{
	int Min;
    Min = I;
    if(J<I--)
 	   Min=J;
    return Min;
}"
2661,"public static int min(int I, int J)
{
	int Min;
    Min = I;
    if(J<++I) {
 	   Min=J;}
    return Min;
}"
2662,"public static int min(int I, int J)
{
	int Min;
    Min = I;
    if(J<I) {
 	   Min=J--;}
    return Min;
}"
2663,"public static int min(int I, int J)
{
	int Min;
    Min = I;
    if(J<I) {
 	   Min=J++;}
    return Min;
}"
2664,"public static int min(int I, int J)
{
	int Min;
    Min = I;
    if(J<=I) {
 	   Min=J;}
    return Min;
}"
2665,"public static int min(int I, int J)
{
	int Min;
    Min = I;
    if(J<I) {
 	   Min=J;}
    return Min--;
}"
2666,"public static int min(int I, int J)
{
	int Min;
    Min = I++;
    if(J<I) {
 	   Min=J;}
    return Min;
}"
2667,"public static int min(int I, int J)
{
	int Min;
    Min = I;
    if(J<I) {
 	   Min=J;}
    return Min++;
}"
2668,"public static int min(int I, int J)
{
	int Min;
    Min = I;
    if(J<I++)
 	   Min=J;
    return Min;
}"
2669,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2670,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse - y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2671,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z / z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2672,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse / z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2673,"public Vector3D orthogonal() {

  double threshold = 0.6 / getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2674,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2675,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z + z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2676,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse - y, -inverse * x, 0);

}"
2677,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (true)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2678,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 - Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2679,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x - y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2680,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y * (z * z));
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2681,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x % (y * y));
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2682,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == -1) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2683,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2684,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse / x, 0);

}"
2685,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 + Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2686,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x == -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2687,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = -1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2688,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x == threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2689,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse / y, -inverse * x, 0);

}"
2690,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x - x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2691,"public Vector3D orthogonal() {

  double threshold = 0.0 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2692,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse / x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2693,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if (false) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2694,"public Vector3D orthogonal() {

  double threshold = 0.6 - getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2695,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 % Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2696,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = -1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2697,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y - y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2698,"public Vector3D orthogonal() {

  double threshold = 0.6 + getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2699,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(1, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2700,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold >= 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2701,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x / x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2702,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse + x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2703,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 1) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2704,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y / y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2705,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z % z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2706,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z % z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2707,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y % y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2708,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2709,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x * (y * y));
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2710,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y > -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2711,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(-1, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2712,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) == (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2713,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse - z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2714,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 % Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2715,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y - y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2716,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x / (y * y));
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2717,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 * Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2718,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y % (z * z));
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2719,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, -1, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2720,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x / x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2721,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (true)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2722,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y < threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2723,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x + x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2724,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 0 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2725,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2726,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse / z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2727,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, +inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2728,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse + x, 0);

}"
2729,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 * Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2730,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse - x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2731,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse + y, -inverse * x, 0);

}"
2732,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y - z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2733,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = -1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2734,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse + y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2735,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y / y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2736,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse % x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2737,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse / y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2738,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse % z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2739,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 + Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2740,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (false) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2741,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse % y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2742,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse + z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2743,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2744,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z - z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2745,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y == -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2746,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if (false) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2747,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 1);

}"
2748,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z / z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2749,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse + z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2750,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse - x, 0);

}"
2751,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 * Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2752,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x * (z * z));
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2753,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x + x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2754,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((true) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2755,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, +inverse * x, 0);

}"
2756,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((true) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2757,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x % (z * z));
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2758,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x % x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2759,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x < threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2760,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, -1);

}"
2761,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 % Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2762,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y + y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2763,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 1, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2764,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y + y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2765,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) == (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2766,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(+inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2767,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x / (z * z));
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2768,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 - Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2769,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y / (z * z));
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2770,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x > -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2771,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse % z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2772,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z + z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2773,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x - z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2774,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 0 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2775,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold <= 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2776,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y == threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2777,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y % y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2778,"public Vector3D orthogonal() {

  double threshold = 0.6 % getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2779,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x - x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2780,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse % x, 0);

}"
2781,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 + Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2782,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse % y, -inverse * x, 0);

}"
2783,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z - z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2784,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= +threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2785,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x % x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2786,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse - z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2787,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 - Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2788,"public Vector3D orthogonal() {

  double threshold = -0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 1 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2789,"public Vector3D orthogonal() {

  double threshold = 0.6 * getNorm();
  if (threshold == 0) {
    throw new ArithmeticException(""null norm"");
  }

  if ((x >= -threshold) && (x <= threshold)) {
    double inverse  = 0 / Math.sqrt(y * y + z * z);
    return new Vector3D(0, inverse * z, -inverse * y);
  } else if ((y >= -threshold) && (y <= threshold)) {
    double inverse  = 1 / Math.sqrt(x * x + z * z);
    return new Vector3D(-inverse * z, 0, inverse * x);
  }
  double inverse  = 1 / Math.sqrt(x * x + y * y);
  return new Vector3D(inverse * y, -inverse * x, 0);

}"
2790,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2791,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2792,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2793,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first--, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2794,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (!(bound < data[upper])) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2795,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2796,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2797,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (-first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2798,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first-- < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2799,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
}"
2800,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first % 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2801,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2802,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i--) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2803,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper++ - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2804,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
}"
2805,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper--, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2806,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (~bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2807,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first * last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2808,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (--bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2809,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper + 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2810,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length;  ) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2811,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first / 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2812,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper-- + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2813,"public  void swap( int[] data, int i, int j )
{
    int tmp = data[i];
    data[i] = data[j];
    data[j] = tmp;
}"
2814,"public  void swap( int[] data, int i, int j )
{
    int tmp = data[i];
    data[i] = data[j];
    data[j] = tmp--;
}"
2815,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2816,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (!(first < upper - 1)) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2817,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, first + last + 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2818,"public  void swap( int[] data, int i, int j )
{
    int tmp = data[i];
    data[i] = data[j];
    data[j] = tmp++;
}"
2819,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last++) {
        quicksort( data, upper + 1, last );
    }
}"
2820,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper < last) {
        quicksort( data, upper + 1, last );
    }
}"
2821,"public  void sort( int[] data )
{
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2822,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2823,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (~bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2824,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (true) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2825,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper - 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2826,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper * 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2827,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i--]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2828,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i >= data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2829,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, -first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2830,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (false) {
        quicksort( data, upper + 1, last );
    }
}"
2831,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first != upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2832,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, ~data.length - 2 );
}"
2833,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i != data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2834,"public  void swap( int[] data, int i, int j )
{
    int tmp = data[i++];
    data[i] = data[j];
    data[j] = tmp;
}"
2835,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first - last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2836,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first++];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2837,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last--;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2838,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper++ );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2839,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2840,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (--upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2841,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, -data.length - 2 );
}"
2842,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[~upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2843,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper--]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2844,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper % 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2845,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper-- - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2846,"public  void sort( int[] data )
{
    if (data.length != 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2847,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2848,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2849,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, ~data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2850,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2851,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) * 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2852,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] >= data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2853,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[++lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2854,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (~first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2855,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2856,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (++lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2857,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[~lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2858,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower > upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2859,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[++i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2860,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[~i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2861,"public  void swap( int[] data, int i, int j )
{
    int tmp = data[i];
    data[i] = data[-j];
    data[j] = tmp;
}"
2862,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (++bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2863,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = -i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2864,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper++) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2865,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper % 1, last );
    }
}"
2866,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2867,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower != upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2868,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2869,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper / 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2870,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < ~last) {
        quicksort( data, upper + 1, last );
    }
}"
2871,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) % 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2872,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max-- );
    quicksort( data, 0, data.length - 2 );
}"
2873,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first-- );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2874,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i++;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2875,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[~first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2876,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 > last) {
        quicksort( data, upper + 1, last );
    }
}"
2877,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (true) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2878,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (true) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2879,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last++;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2880,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= ++upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2881,"public  void swap( int[] data, int i, int j )
{
    int tmp = data[i];
    data[i] = data[~j];
    data[j] = tmp;
}"
2882,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower > upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2883,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound != data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2884,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[--lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2885,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i++ < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2886,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2887,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, -last );
    }
}"
2888,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i-- < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2889,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last-- );
    }
}"
2890,"public  void swap( int[] data, int i, int j )
{
    int tmp = data[i];
    data[i] = data[j];
    data[j] = -tmp;
}"
2891,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2892,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < ~data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2893,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper-- - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2894,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first++ < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2895,"private  void quicksort( int[] data, int first, int last )
{
    int lower = ~first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2896,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2897,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound++ < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2898,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (~first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2899,"public  void swap( int[] data, int i, int j )
{
    int tmp = data[i--];
    data[i] = data[j];
    data[j] = tmp;
}"
2900,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i == data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2901,"private  void quicksort( int[] data, int first, int last )
{
    int lower = -first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2902,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper % 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2903,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (!(bound > data[lower])) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2904,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, -first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2905,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, -max );
    quicksort( data, 0, data.length - 2 );
}"
2906,"public  void swap( int[] data, int i, int j )
{
    int tmp = data[i];
    data[i] = data[j--];
    data[j] = tmp;
}"
2907,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower++]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2908,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper-- + 1, last );
    }
}"
2909,"public  void swap( int[] data, int i, int j )
{
    int tmp = data[i];
    data[i] = data[--j];
    data[j] = tmp;
}"
2910,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower++ <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2911,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last--) {
        quicksort( data, upper + 1, last );
    }
}"
2912,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i > data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2913,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, -first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2914,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < ~upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2915,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper, last );
    }
}"
2916,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (false) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2917,"public  void swap( int[] data, int i, int j )
{
    int tmp = data[i];
    data[i] = data[j];
    data[~j] = tmp;
}"
2918,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper++ - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2919,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length / 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2920,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, ~max );
    quicksort( data, 0, data.length - 2 );
}"
2921,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = ~last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2922,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (true) {
        quicksort( data, upper + 1, last );
    }
}"
2923,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length );
}"
2924,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower++ < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2925,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2926,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (~upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2927,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (++upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2928,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= --upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2929,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper--) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2930,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[-first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2931,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first-- + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2932,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper % 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2933,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower != upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2934,"public  void swap( int[] data, int i, int j )
{
    int tmp = data[i];
    data[~i] = data[j];
    data[j] = tmp;
}"
2935,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last++) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2936,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, ++upper + 1, last );
    }
}"
2937,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2938,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper++ + 1, last );
    }
}"
2939,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2940,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] > data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2941,"public  void sort( int[] data )
{
    if (data.length >= 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2942,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (--first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2943,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound == data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2944,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (~lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2945,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[~max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2946,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper - 1, last );
    }
}"
2947,"public  void sort( int[] data )
{
    if (false) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2948,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (--first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2949,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = -last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2950,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower--, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2951,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2952,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first / last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2953,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length / 2 );
}"
2954,"public  void swap( int[] data, int i, int j )
{
    int tmp = data[i];
    data[j] = tmp;
}"
2955,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first >= upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2956,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper * 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2957,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
             ;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2958,"public  void sort( int[] data )
{
    if (true) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2959,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last--) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2960,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length * 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2961,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first++ + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2962,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper++, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2963,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + --last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2964,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[--upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2965,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] != data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2966,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound >= data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2967,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length;) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2968,"public  void swap( int[] data, int i, int j )
{
    int tmp = data[i];
    data[i] = data[j];
    data[j] = ++tmp;
}"
2969,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, first + last );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2970,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, ~lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2971,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower >= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2972,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + ~last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2973,"public  void swap( int[] data, int i, int j )
{
    int tmp = data[-i];
    data[i] = data[j];
    data[j] = tmp;
}"
2974,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, -data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2975,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 != last) {
        quicksort( data, upper + 1, last );
    }
}"
2976,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (--lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2977,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i <= data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2978,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last++ );
    }
}"
2979,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; !(i < data.length); i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2980,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower-- <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2981,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i++]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2982,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    quicksort( data, 0, data.length - 2 );
}"
2983,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2984,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length + 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2985,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, ~first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2986,"public  void swap( int[] data, int i, int j )
{
    int tmp = data[i];
    data[i] = data[j];
    data[j] = ~tmp;
}"
2987,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < ++upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2988,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[--i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
2989,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first > upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2990,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (++first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2991,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= ~upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2992,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound == data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2993,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
             ;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2994,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper * 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2995,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2996,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 <= last) {
        quicksort( data, upper + 1, last );
    }
}"
2997,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first % last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2998,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound-- < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
2999,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower == upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3000,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, -upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3001,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound++ > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3002,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (++bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3003,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, first + last - 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3004,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length * 2 );
}"
3005,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first--];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3006,"public  void sort( int[] data )
{
    if (!(data.length < 2)) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
3007,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < ++upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3008,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper--) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3009,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < --upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3010,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound <= data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3011,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower--;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3012,"public  void sort( int[] data )
{
    if (data.length <= 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
3013,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (++lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3014,"public  void swap( int[] data, int i, int j )
{
    int tmp = data[i];
    data[i] = data[++j];
    data[j] = tmp;
}"
3015,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper + 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3016,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; ++i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
3017,"public  void swap( int[] data, int i, int j )
{
    int tmp = data[i];
    data[i] = data[j++];
    data[j] = tmp;
}"
3018,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower < upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3019,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper++;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3020,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, ~first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3021,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, -upper + 1, last );
    }
}"
3022,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper++]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3023,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first--, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3024,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper / 1, last );
    }
}"
3025,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; --i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
3026,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max++ );
    quicksort( data, 0, data.length - 2 );
}"
3027,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper / 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3028,"private  void quicksort( int[] data, int first, int last )
{
    int lower = 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3029,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3030,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, 2 );
}"
3031,"public  void swap( int[] data, int i, int j )
{
    int tmp = data[~i];
    data[i] = data[j];
    data[j] = tmp;
}"
3032,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
             ;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3033,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first-- + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3034,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, ~upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3035,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound <= data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3036,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first++ + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3037,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (!(data[max] < data[i])) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
3038,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, 1, last );
    }
}"
3039,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (++first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3040,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (false) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3041,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, --upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3042,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 == last) {
        quicksort( data, upper + 1, last );
    }
}"
3043,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (false) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3044,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, ++upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3045,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper++ + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3046,"public  void sort( int[] data )
{
    if (data.length > 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
3047,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3048,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower <= upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3049,"public  void sort( int[] data )
{
    if (data.length == 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
3050,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (--lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3051,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3052,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < ~upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3053,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, ~last );
    }
}"
3054,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper++) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3055,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (!(lower <= upper)) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3056,"public  void swap( int[] data, int i, int j )
{
    int tmp = data[i];
    data[i] = data[j];
}"
3057,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 >= last) {
        quicksort( data, upper + 1, last );
    }
}"
3058,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[++max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
3059,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound >= data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3060,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3061,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower--]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3062,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first++, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3063,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower-- < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3064,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first == upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3065,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, ~upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3066,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[--max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
3067,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first++, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3068,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length + 2 );
}"
3069,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length % 1, max );
    quicksort( data, 0, data.length - 2 );
}"
3070,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] == data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
3071,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (~lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3072,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = ~i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
3073,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first++ );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3074,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max++] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
3075,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, ~upper + 1, last );
    }
}"
3076,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i--;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
3077,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = ++i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
3078,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, --upper + 1, last );
    }
}"
3079,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, ~first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3080,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; ~i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
3081,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound-- > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3082,"public  void swap( int[] data, int i, int j )
{
    int tmp = data[i];
    data[i] = data[j];
    data[j] = --tmp;
}"
3083,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (!(lower < upper)) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3084,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound != data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3085,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound < data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3086,"public  void sort( int[] data )
{
    if (~data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
3087,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + ++last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3088,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first - 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3089,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < --upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3090,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower--;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3091,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3092,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower == upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3093,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length, max );
    quicksort( data, 0, data.length - 2 );
}"
3094,"private  void quicksort( int[] data, int first, int last )
{
    int lower = ++first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3095,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (--bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3096,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length % 2 );
}"
3097,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max--] < data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
3098,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] < data[i]) {
            max = --i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
3099,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, -upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3100,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper * 1, last );
    }
}"
3101,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first <= upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3102,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first * 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3103,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
    }
}"
3104,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower >= upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3105,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (!(upper + 1 < last)) {
        quicksort( data, upper + 1, last );
    }
}"
3106,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper / 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3107,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, ~upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3108,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound > data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3109,"private  void quicksort( int[] data, int first, int last )
{
    int lower = --first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
3110,"public  void sort( int[] data )
{
    if (data.length < 2) {
        return;
    }
    int max = 0;
    for (int i = 1; i < data.length; i++) {
        if (data[max] <= data[i]) {
            max = i;
        }
    }
    swap( data, data.length - 1, max );
    quicksort( data, 0, data.length - 2 );
}"
3111,"private  void quicksort( int[] data, int first, int last )
{
    int lower = first + 1;
    int upper = last;
    swap( data, first, (first + last) / 2 );
    int bound = data[first];
    while (lower <= upper) {
        while (bound > data[lower]) {
            lower++;
        }
        while (bound < data[++upper]) {
            upper--;
        }
        if (lower < upper) {
            swap( data, lower++, upper-- );
        } else {
            lower++;
        }
    }
    swap( data, upper, first );
    if (first < upper - 1) {
        quicksort( data, first, upper - 1 );
    }
    if (upper + 1 < last) {
        quicksort( data, upper + 1, last );
    }
}"
